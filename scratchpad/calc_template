#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# pip3 install --user scipy --upgrade
# pip3 install --user numpy --upgrade
# pip3 install --user matplotlib --upgrade

##=Raw================
# hex:    0xDEADBEEF
# to hex: hex(number)

# binary: 0b1011_1111
# to bin: bin(number)

# octet:  0100

# char -> raw: ord('a')
# raw -> char: chr(97)

# Math functions
# math.log(x)
# xor(x,y)

# hex encoded -> utf8 string
# bytearray.fromhex(hex).decode('utf-8')
# hex encoded -> raw
# binascii.unhexlify(hex)

# base64
# e = base64.b64encode(b'...')
# p = base64.b64decode(e)

# urlencode
# e = urllib.parse.quote(p)
# p = urllib.parse.unquote(e)
# dict = urllib.parse.parse_qs(p)

# sha256
# m = hashlib.sha256()
# m.update(binascii.unhexlify(""))
# m.hexdigest()/m.digest()

# random
# hex(random.getrandbits(32))
# random.randint(1, 10)

# socket.ntohl()
# ===================

import sys
import math
import binascii
import hashlib
import random
from operator import xor
import numpy as np
import scipy
import matplotlib.pyplot as plt
import socket
import base64
import urllib

sys.version

k = 1000.
M = k*k
m = 1./1000.
μ = 1./(1000.*1000.)
π=np.pi
π2=π*2.

def mod_exp(b, e, m):
  """
  https://github.com/csknk/fast-modular-exponentiation/blob/master/python/main.py
  bᵉ (mod m)
  """
  r = 1
  if 1 & e:
    r = b
  while e:
    e >>= 1
    b = (b * b) % m
    if e & 1: r = (r * b) % m
  return r

def gcd(a, b):
  if b == 0:
    return a
  else:
    return gcd(b, a%b)

def deg2rad(deg):
  return deg*(np.pi/180.)

def rad2deg(rad):
  return rad*(180./np.pi)

sys.setrecursionlimit(1500)

