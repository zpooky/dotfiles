" Turn off vi compatibility.(sould be set first)
set nocompatible

" always show tab bar
set showtabline=2
" the limit of the number of files opened by vim -p
set tabpagemax=100

" {{{
" shorter info messages
set shortmess=flmnrwI
" }}}

" encoding {{{
set encoding=utf-8      " The encoding used
set fileencoding=utf-8  " The encoding of the resulting output file
scriptencoding utf-8
" }}}

if has('gui_running')
  " configure font and font size for gvim
  " set guifont=Consolas:h9

  " a gui pops up allowing you to configure font, size...
  " set guifont=*
endif

" if $TERM == "xterm-256color"
" endif

function! s:IsWSL()
  let lines = substitute(system('uname -a'),'\n','','')
  if lines =~ "Microsoft"
    return 1
  endif
  return 0
endfunction

if s:IsWSL()
  " somewhat fixes the bugged backgound in WSL+alacritty+vim
  set t_ut=
endif

if $TERM == "alacritty" || $TERM == "xterm-256color" || $TERM == "screen-256color" || $COLORTERM == "gnome-terminal" || $TERM == "urxvt" || $TERM == "tmux-256color" || has('nvim')
  set t_Co=256
  if has('nvim') || has('termguicolors')
    " :h xterm-true-color
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    " :h termguicolors
    " guibg and guifg are defined also in terminal Vim used by colorscheme
    set termguicolors
  endif
endif

silent! colorscheme codedark

if v:version > 703 || v:version == 703 && has('patch541') || has('nvim')
  " Fixes joining comment lines
  set formatoptions+=j
endif

"
filetype on                       " Enable file type detection
filetype plugin on                " Enable file type plug-ins
filetype indent plugin on         " file type specific indentation support + loading language indentation specific files

" General {{{
let mapleader = "\<Space>"        " map leader to  <space>
" set mouse=a                     " Enables scrolling terminal.(mouse mode)
set pastetoggle=<f5>              " vim will not perform any formatting when toggled on
" }}}
" UI {{{
set ruler                         " Display the ruler
set showcmd                       " Show incomplete vim motions as I type
set relativenumber                " Relative line numbers
set number                        " Relative + Absolute number
set lazyredraw                    " don't bother updating screen during macro playback
" set showmatch                     " blink matching [{()}] on insert
set title                         " change the terminal's title

set novisualbell                  " don't beep
set noerrorbells                  " don't beep

set splitright                    " open new pane to the right

set scrolloff=1                   " keep at least N lines above/below when scrolling

" if !has('win32unix') && !has('win64unix')
  " does not work in cygwin
  " set ttyfast                     " Faster redraw
" endif

" Highlight current line
" Enable cursorline only on the active buffer
augroup AutogroupCursorLine
    "https://stackoverflow.com/a/12018552
    autocmd!
    autocmd VimEnter,WinEnter,BufWinEnter * setlocal cursorline
    autocmd WinLeave * setlocal nocursorline
augroup END

" no top level buffer is displayed when using autosggestion
set completeopt-=preview
" }}}

" syntax {{{
syntax enable                     " Highlight the syntax.
" }}}

" folding {{{
set nofoldenable                  " disable folding
" }}}

" gvim {{{
" hide all gui
set guioptions=
" }}}

" command(:) {{{
set history=1000                 " remember more commands and search history
set wildmode=longest:full,full   " bash like command(:) completion when tab
set wildmenu                     " Show command(:) completion with tab

" Suffixes that get lower priority when doing tab completion for filenames.
" These are files we are not likely to want to edit or read.
set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc,.png,.jpg

" ignore these files when :edit <tab>
set wildignore=*.swp,*.bak,*.pyc,*.exe,*.dat,*.bin,*.out,*.pdf,*.cache,*.part
set wildignore+=*.tmp
set wildignore+=*.d,main,*.o,*.a,*.stackdump,*.so
set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png,*.mkv,*.mp4
set wildignore+=*.class,*.jar
set wildignore+=*.zip,*.tar,*.tar.gz
set wildignore+=GPATH,GRTAGS,GTAGS
" TODO does not work
set wildignore+=*~

set wildignore+=*/node_modules/*
set wildignore+=*/tmp/*
set wildignore+=*/target/*
set wildignore+=*/build/*

set wildignore+=*/.git,*/.hg,*/.svn
set wildignore+=tags,*.tags

set wildignore+=external/googletest/*
set wildignore+=*external/googletest/*
set wildignore+=*/external/googletest/*

set wildignore+=external/googletest*
set wildignore+=*external/googletest*
set wildignore+=*/external/googletest*

set wildignore+=external/googletest
set wildignore+=*external/googletest
set wildignore+=*/external/googletest

set wildignore+=external/googletest/
set wildignore+=*external/googletest/
set wildignore+=*/external/googletest/

set wildignore+=external/googletest/**
set wildignore+=*external/googletest/**
set wildignore+=*/external/googletest/**

set wildignore+=external/googletest**
set wildignore+=*external/googletest**
set wildignore+=*/external/googletest**
"","build/**","build_test/**"
" let g:CommandTWildIgnore=&wildignore . ",external/googletest/**"

" set wildignore+=
" }}}


augroup AutogroupRememberFilePosition
  autocmd!
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif
augroup END

if has('win32unix') || has('win64unix')
  " cursor shape
  " https://github.com/mintty/mintty/wiki/Tips
  let &t_ti ="\e[1 q"           " put terminal in termcap mode
  let &t_SI ="\e[5 q"           " Start insert mode
  let &t_EI ="\e[1 q"           " End insert or replace mode
  let &t_te ="\e[0 q"           " out of termcap mode

  let &t_ti ="\e[?7727h"
  let &t_te ="\e[?7727l"
  " noremap <Esc>O[ <Esc>
  " noremap! <Esc>O[ <C-c>
else
  " alacritty cursor shape settings does not work inside tmux
  let &t_SI = "\<Esc>[6 q" " pipe
  let &t_SR = "\<Esc>[4 q" " underline
  let &t_EI = "\<Esc>[0 q" " block
endif

" ttimout ==keycode timeout
" timout == mapping timeout
" Get rid of nasty lag on ESC (timeout and ttimeout seem useless) sp??
augroup AutogroupEscapeLag
  autocmd!
  au InsertEnter * set timeoutlen=1
  au InsertLeave * set timeoutlen=1000
augroup END
set timeoutlen=1000 ttimeoutlen=0
" set esckeys " A <esc> is always a <esc> not part a escape sequence(used by older terminals?)

" Blank characters {{{
" debug set with "set list?" ?: means print current value
set list                              " show special chars, such as tab: eol: trail: extends: nbsp:

" chars to show for blank characters
set listchars=tab:\ \ 
" set listchars+=tab:·»
" set listchars+=eol:¬
set listchars+=trail:·
set listchars+=nbsp:+

" set showbreak=↪\
" char to display when softwrapping
set showbreak="\u21aa"
" }}}

" Search {{{
set incsearch                     " search wile you type
set smartcase                     " Case insensitive search, except when capital letters are used.
set ignorecase                    " ignore case when searching
set hlsearch                      " highlight search result
" }}}

" Visual mode {{{
" move up/down by visual line, will treat wrapped lines as real lines
nnoremap j gj
nnoremap k gk
" }}}

" Spell {{{
function! s:SpSpell()
  setlocal spell!
  if &spell is 1
    echomsg "spell (".&spelllang.")"
  else
    echomsg "nospell"
  endif
  return 0
endfunction
command! SpSpell :call s:SpSpell()
nmap <silent> <f6> :SpSpell<cr>
map zn ]s
map zp [s
map zN [s
" map <leader>sa zg
" map <leader>sq z=
" Drop down menu with spell corrections
nnoremap <leader>z ea<C-X><C-S>

" underline wrongly spelled words
" hi clear SpellBad
" hi SpellBad cterm=underline gui=underline

" set spelllang=en_gb               " Specify the spell checking language.
set nospell                       " Disable spell checking by default.
set dictionary+=/usr/share/dict/words
" Own spell db
set spellfile=~/.vim/spell/en.utf-8.add

iab terminting terminating
iab nummber number
iab acourences occurrences
iab upcomming upcoming
iab sorounding surrounding
iab surounding surrounding
iab coefficent coefficient
iab inverant invariant
iab instantanious instantaneous
iab equavivalent equivalent
iab equvletnt equivalent
iab equvalent equivalent
iab widly widely
iab equavailent equivalent
iab becuase because
iab cuircut circuit
iab usuaully usually
iab ordenary ordinary
iab postitive positive
iab manifactor manufacture
iab handeling handling
iab throguh through
iab meassures measures
iab vaccum vacuum
iab througout throughout
iab meassure measure
iab dificult difficult
iab colide collide
iab meassured measured
iab postive positive
iab independant independent
iab beleafe belief
iab dicease decease
iab decase decease
iab falsly falsely
iab curtany certainty
iab frequncy frequency
iab unrequsted unrequested
iab indpendant independent
iab sucesses successes
iab successfull successful
iab proability probability
iab makeing making
iab thease these
iab periphrials peripherals
iab colission collision
iab arives arrives
iab performe perform
iab noice noise
iab Noice Noise
iab refred referred
iab allso also
iab meassuring measuring
iab reprecente represent
iab speach speech
iab buttom bottom
iab necessarly necessarily
iab importently importantly
iab asynchroniozly asynchronously
iab occours occurs
iab registring registering
iab asynchroniosly asynchronously
iab existance existence
iab includeing including
iab differense difference
iab preassure pressure
iab ressitance resistance
iab pressoure pressure
iab collissions collisions
iab meassurement measurement
iab inlude include
iab simular similar
iab reliabily reliably
iab adjasent adjacent
iab incldue include
iab indestingishable indistinguishable
iab pressent present
iab maintaned maintained
iab mehtod method
iab traling trailing
iab destinguised distinguished
iab sermony ceremony
iab indefently indefinitely
iab accour occur
iab recieved received
iab choises choices
iab performes performs
iab receipient recipient
iab unpriviliged unprivileged
iab affetcs affects
iab occopy occupy
iab acces access
iab conecpt concept
iab acomplished accomplished
iab creater creator
iab signifys signifies
iab histroy history
iab completelty completely
iab lier liar
iab perfrom perform
iab porpuse purpose
iab periodicly periodically
iab incompatibal incompatible
iab continueing continuing
iab divergant divergent
iab commiting committing
iab respons response
iab differntiate differentiate
iab referse refers
iab achived achieved
iab specificly specifically
iab reproducable reproducible
iab globaly globally
iab formated formatted
iab atomatic automatic
iab primarly primarily
iab capabillities capabilities
iab dubble double
iab referes refers
iab transmiited transmitted
iab refere refer
iab activly actively
iab lazyily lazily
iab affectlivy affectively
iab avilable available
iab abreviate abbreviate
iab achives achieves
iab absoloutly absolutely
iab adjasent adjacent
iab advandatges advantages
iab Advandatges Advantages
iab afer after
iab aggreeing agreeing
iab algoithm algorithm
iab algorihm algorithm
iab allready already
iab allways always
iab alot allot
iab anounce announce
iab apend append
iab aquire acquire
iab arbritrary arbitrary
iab artices articles
iab aswell as well
iab atleast at least
iab atomicly atomically
iab autocompleteion autocompletion
iab beacuse because
iab beahviour behaviour
iab biset bitset
iab bootstraping bootstrapping
iab changeing changing
iab charactor character
iab closenes closeness
iab coalecse coalesce
iab coaless coalesce
iab coalessce coalesce
iab coalesse coalesce
iab coalessed coalesced
iab configred configured
iab compareing comparing
iab comparision comparison
iab compatability compatibility
iab completeion completion
iab considure consider
iab continuasly continuously
iab controll control
iab conuccrency concurrency
iab conestexpr constexpr
iab coresponding corresponding
iab corresponing corresponding
iab defein define
iab defien define
iab deque dequeue
iab dequed dequeued
iab dequeing dequeuing
iab desiding deciding
iab enque enqueue
iab enqued enqueued
iab enquing enqueuing
iab entrie entry
iab everyting everything
iab exapndable expandable
iab exclusve exclusive
iab exclusve exclusive
iab Exclusve Exclusive
iab Exlcusive Exclusive
iab explict explicit
iab externaly externally
iab fasle false
iab flase false
iab fro for
iab fullfill fulfil
iab haveing having
iab hegiher higher
iab heigher higher
iab highligt highlight
iab immediatly immediately
iab inbetwen in-between
iab increse increase
iab indecies indices
iab infront in front
iab initialy initially
iab interfereing interfering
iab invoce invoke
iab invoces invokes
iab itterating iterating
iab itteration iteration
iab itterations iterations
iab itterated iterated
iab itterates iterates
iab keept kept
iab lengh length
iab lengt length
iab liklyhood likelihood
iab malicous malicious
iab meaining meaning
iab namesapce namespace
iab nessesarly necessarily
iab nessesarily necessarily
iab nessesary necessary
iab nessessary necessary
iab noxcept noexcept
iab ovrride override
iab ovrrides overrides
iab paralell parallel
iab Paralell Parallel
iab Comunnication Communication
iab comunnication communication
iab possitive positive
iab possitve positive
iab possitves positives
iab prefere prefer
iab prinf printf
iab privous previous
iab probobly probably
iab publlic public
iab ranomize randomize
iab realy really
iab rebalace rebalance
iab rebalanceing rebalancing
iab rebalnce rebalance
iab reclmataion reclamation
iab recuirsive recursive
iab recurisvly recursively
iab recurivly recursively
iab recursivily recursively
iab recursivly recursively
iab recycked recycled
iab referecnes references
iab refered referred
iab refrence reference
iab refrenced referenced
iab refrences references
iab renmae rename
iab represnetation representation
iab routign routing
iab staticts statistics
iab subsicently subsequently
iab sufficent sufficient
iab surten certain
iab teh the
iab therefor therefore
iab thresshold threshold
iab tradeoff trade-off
iab uppwards upwards
iab utillity utility
iab wehn when
iab wheter whether
iab wich which
iab separtly separately
iab entires entries
iab alais alias
iab staticly statically
iab unitialized uninitialized

iab predessessor predecessor
iab predeccsessor predecessor
iab beacause because
iab chanse chance
iab beinning beginning
iab begining beginning
iab verticly vertically
iab succesfull successful
iab inorder in order
iab remvoe remove
iab allignment alignment
iab theorum theorem
iab theorum theorem
iab statefull stateful
iab otherwsie otherwise
iab commited committed
iab indivudal individual
iab persistant persistent
iab coalecced coalesced
iab mutiple multiple
iab acure occur
iab occures occurs
iab transction transaction
iab trsanction transaction
iab durabilty durability
iab alteres alterers
iab othwise otherwise
iab othrwise otherwise
iab lenght length
iab lengh length
iab halvf half
iab namepsace namespace
iab reutrn return
iab sucessor successor
iab changess changes
iab gatter gather
iab scather scatter
iab Completly Completely
iab completly completely
iab pidgeons pigeons
iab occopies occupies
iab Miliseconds Milliseconds
iab miliseconds milliseconds
iab exersize exercise
iab receave receive
iab algoritm algorithm
iab propigate propagate
iab potentily potentially
iab everythin everything
iab greather greater
iab optomizations optimizations
iab optomization optimization
iab referernce reference
iab manny many
iab aight eight
iab outherwise otherwise
iab symantics semantics
iab resutl result
iab reuslt result
iab correcly correctly
iab epexcted expected
iab sence sense
iab isntead instead
iab ambigous ambiguous
iab Concensus Consensus
iab concensus consensus
iab exlusivly exclusively
iab eachother each other
iab heigh height
iab heigth height
iab useing using
iab collission collision
iab handleing handling
iab seaerching searching
iab responsiblity responsibility
iab supossed supposed
iab deapth depth
iab beahvior behaviour
iab realying relaying
iab exclusivly exclusively
iab whith with
iab reslease release
iab theire their
iab thier their
iab Investiaged Investigated
iab investiaged investigated
iab decentrialized decentralized
iab intrest interest
iab instreast interest
iab intresting interesting
iab effecivly effectively
iab wil will
iab experiance experience
iab develping developing
iab greate great
iab considor consider
iab abbeility ability
iab algorihms algorithms
iab postion position
iab avialable available
iab moddeling modelling
iab curomstances circumstances
iab expirement experiment
iab toughts toughs
iab effectivly effectively
iab considuration consideration
iab clousre closure
iab createing creating
iab resullt result
iab wether whether
iab optimaize optimize
iab intrested interested
iab excpected expected
iab excpect expect
iab Allways Always
iab decieds decides
iab higest highest
iab negotitaiton negotiation
iab stepps steps
iab permitts permits
iab alloted allotted
iab usuable useable
iab independant independent
iab generaly generally
iab Generaly Generally
iab rentrant re-entrant
iab interuptable interruptible
iab postion position
iab sapce space
iab utilazing utilizing
iab beeing being
iab developmeant development
iab companines companies
iab mehtologies methodologies 
iab problmes problems
iab owerwite overwrite
iab Usualy Usually
iab usualy usually
iab runinning running
iab interputs interrupts
iab interput interrupt
iab occured occurred
iab writeable writable
iab perstisting persisting
iab placeces places
iab trhough through
iab deivce device
iab deivces devices
iab appropreate appropriate
iab appopriate appropriate
iab befroe before
iab ciruclarly circularly
iab collectivly collectively
iab interrput interrupt
iab interupt interrupt
iab automaticly automatically
iab trhough through
iab primarirly primarily
iab implemenation implementation
iab dynamicly dynamically
iab usefull useful
iab requres requires
iab appart apart
iab nameing naming
iab equevivalent equivalent
iab byts bytes
iab originial original
iab manny many
iab reacreate recreate
iab modifieing modifying
iab multiplcation multiplication
iab sorunded surrounded 
iab sorunded surrounded 
iab infered inferred
iab operaions operations
iab operaion operation
iab calcuation calculation
iab Devision Division
iab devision division
iab circuts circuits
iab proffesional professional
iab causion caution
iab properietary proprietary
iab concour conquer
iab fibbunacci fibonacci
iab ous us
iab memoziation memoization
iab usaly usually
iab instanceiation instantiation
iab accumelated accumulated
iab cordinates coordinates
iab cordinate coordinate
iab diffrent different
iab pice piece
iab witouth without
iab visting visiting
iab twise twice
iab paramters parameters
iab trivialy trivially
iab erroniously erroneously
iab optimiziation optimization
iab bidirecetional bidirectional
iab canditates candidates
iab whre where
iab visualy visually
iab incorpereated incorporated
iab occurence occurrence
iab sciensce science
iab sencor sensor
iab delte delete
iab chipertext ciphertext
iab ossilates oscillates
iab possitve positive
iab neagative negative
iab ossilation oscillation
iab frequence frequency
iab Bandwith Bandwidth
iab bandwith bandwidth
iab betwen between
iab vacum vacuum
iab priviously previously
iab alghorithms algorithms
iab alghorithm algorithm
iab adjacensy adjacency
iab descised disguised
iab deapest deepest
iab Obsolite Obsolete
iab obsolite obsolete
iab descise disguise
iab descise disguise
iab descised disguised
iab privously previously
iab chagenes changes
iab applyed applied
iab mapps maps
iab afther after
iab depndency dependency
iab messourement measurement
iab neaded needed
iab Dynamicly Dynamically
iab throu through
iab itnerface interface
iab reuslt result
iab yeilds yields
iab yeild yield
iab elivator elevator
iab collission collision
iab recipiant recipient
iab utlize utilize
iab receipent recipient
iab recipent recipient
iab depricated deprecated
iab identifyed identified
iab opperate operate
iab communcation communication
iab resposne response
iab coaxal coaxial
iab recieved received
iab recepient recipient
iab comming coming
iab incomming incoming
iab refferences references
iab refference reference
iab faviroable favourable
iab unfaivorable unfavourable
iab unsuccessfull unsuccessful
iab porpuses purposes
iab intreseted interested
iab intrestign interesting
iab stero stereo
iab compenent component
iab refering referring
iab positivly positively
iab negativly negatively
iab infinte infinite
iab accesable accessible
iab angulare angular
iab normailzed normalized
iab digtal digital
iab preasure pressure
iab difficuilt difficult
iab momentome momentum
iab enoguh enough
iab permeabillity permeability
iab achive achieve
iab basicly basically
iab possibilites possibilities
iab representated represented
iab signficant significant
iab succes success
iab myabe maybe

iab Acsending Ascending
iab acsending ascending
iab Asending Ascending
iab asending ascending
iab Acending Ascending
iab acending ascending

iab Decsending Descending
iab decsending descending
iab Desending Descending
iab desending descending
iab Decending Descending
iab decending descending

iab holded holed
iab Digitial Digital
iab digitial digital

" TODO maybe limit to ft=cpp
iab sizoef sizeof
iab doubel double
iab deinfe define
iab memst memset
iab szie_t size_t
iab stati static
" iab uint8 uint8_t
" iab uint16 uint16_t
" iab uint32 uint32_t
" iab uint64 uint64_t
iab cosnt const
iab asssert assert
iab treu true
iab pritnf printf
iab szie_t size_t
iab typdef typedef

iab distrubition distribution

" iab nullpt nullptr
" iab nullp nullptr
" iab null nullptr
" }}}

set nowrap                        " do not soft wrap long lines
set backspace=indent,eol,start    " allow backspacing over everything in insert mode
set autoread                      " auto reload after outside changes(tmux sends a event on focus)

" Indentation {{{
" set autoindent                    " use the same indent from current line when starting a new line
" set copyindent                    " use the same character(tabs,spaces...) for indentation as the previous line
" set smartindent                   " support auto indentation when for example the previous line end with { used for (c/c++)
" }}}

" tmp directories {{{
function! s:SetupTmp()
  if has("win32")
    set noswapfile          " no swap
    set noundofile          " no undo file
    set nobackup            " no bak
  else
    let l:root = "/tmp/.vim-".$USER
    if !isdirectory(l:root)
      call mkdir(l:root, "", 0700)
    endif

    " let l:root = l:base."/".$USER
    " if !isdirectory(l:root)
    "   call mkdir(l:root, "", 0700)
    " endif

    " Undo {{{
    let l:undo = l:root."/undo"
    if !isdirectory(l:undo)
      call mkdir(l:undo, "", 0700)
    endif
    " https://advancedweb.hu/2017/09/12/vim-using-undo-branches
    set undolevels=1000               " Use many levels of undo
    set undofile                      " File Persistent undo
    " set undodir=l:undo."//"           " Store undo file in tmp directory
    set undodir=/tmp/.vim-$USER/undo//
    " }}}

    " swap lock file {{{
    let l:swap =l:root."/swap"
    if !isdirectory(l:swap)
      call mkdir(l:swap, "", 0700)
    endif
    " two slashes means that vim will create unique swap file names per file
    " set directory=l:swap.//
    set directory=/tmp/.vim-$USER/swap//
    set swapfile
    " }}}

    " Backup {{{
    let l:backup = l:root."/backup"
    if !isdirectory(l:backup)
      call mkdir(l:backup, "", 0700)
    endif
    set nobackup            " no bak
    " set backup
    " pointles to backup to /tmp?
    " set backupdir=/tmp/.vim/backup//
    " set backupskip=/tmp/*,~/tmp
    " set writebackup
    " }}}

  endif
endfunction
call s:SetupTmp()

if has('nvim')
  set viminfo+=n~/.cache/nvim/viminfo
else
  set viminfo+=n~/.cache/vim/viminfo
endif
" }}}

" Custom mappings {{{
" Alternative save
" TODO if tabs > 1 do this. other wise remove 'silent!'
nnoremap <leader>w <esc>:silent! wa<CR>
" Alternative quit
nnoremap <silent> <leader>q <esc>:q<CR>

map <silent> <leader>, <esc>:noh<CR>

" resize split
map <silent> <leader>- <esc>:vertical resize -5<CR>
map <silent> <leader>+ <esc>:vertical resize +5<CR>

" Alternative Moving around splits with the leader key
nmap <silent> <leader>h :wincmd h<CR>
nmap <silent> <leader>j :wincmd j<CR>
nmap <silent> <leader>k :wincmd k<CR>
nmap <silent> <leader>l :wincmd l<CR>

" Create vertical pane
nnoremap <leader>s <esc>:vnew<CR>
" Create horizontal pane
" nnoremap <leader>h <esc>:sp<CR>
" Create tab
nnoremap <silent><leader>e <esc>:tabedit<CR>

" new line above and below without entering insert mode
map <silent> <leader>o o<esc>
map <silent> <leader>O O<esc>

" behave similar to D
noremap Y y$
"
" Navigation capital H/L goto extreme Right/Left
noremap H _
noremap L g_

nnoremap <CR> :
vnoremap <CR> :

" Replay macro
noremap Q @q

" }}}

" jumplist {{{
" Store relative line number jumps in the jumplist if they exceed a threshold.
nnoremap <expr> k (v:count > 3 ? "m'" . v:count : '') . 'k'
nnoremap <expr> j (v:count > 3 ? "m'" . v:count : '') . 'j'

nnoremap <expr> + (v:count > 3 ? "m'" . v:count : '') . '+'
nnoremap <expr> - (v:count > 3 ? "m'" . v:count : '') . '-'
" }}}

" Disable Mappings {{{

" Arrow keys
" nnoremap <left> <nop>
" nnoremap <right> <nop>
" nnoremap <up> <nop>
" nnoremap <down> <nop>
"
" inoremap <left> <nop>
" inoremap <right> <nop>
" inoremap <up> <nop>
" inoremap <down> <nop>

" does not work
" nnoremap <s+left> <nop>
" nnoremap <s+right> <nop>
" nnoremap <s+up> <nop>
" nnoremap <s+down> <nop>
"
" inoremap <s+left> <nop>
" inoremap <s+right> <nop>
" inoremap <s+up> <nop>
" inoremap <s+down> <nop>


" disable f1 help
inoremap <F1> <nop>
nnoremap <F1> <nop>
vnoremap <F1> <nop>

" disable man
map <S-k> <Nop>

" Avoid unintentional switches to Ex mode.
nnoremap Q <nop>

" Stop that stupid window from popping up
nmap q: <esc>:q

" remember both line and column with '
nnoremap ' `
nnoremap ` '

"
map + <nop>
map - <nop>

" Keep visual selection during indenting
xnoremap < <gv
xnoremap > >gv|

" }}}

" hexedit {{{
" from :h hex-editing
" xxd is a utility to convert to/from hex - used when opening and closing the
" bin files. when opening a bin file vim will open it for hex editing
augroup BinaryHexEdit
  au!
  au BufReadPre   *.bin,*.img,*.wav,*.pcm,*.raw let &bin=1
  au BufReadPost  *.bin,*.img,*.wav,*.pcm,*.raw if &bin | %!xxd
  au BufReadPost  *.bin,*.img,*.wav,*.pcm,*.raw set ft=xxd | endif
  au BufWritePre  *.bin,*.img,*.wav,*.pcm,*.raw if &bin | %!xxd -r
  au BufWritePre  *.bin,*.img,*.wav,*.pcm,*.raw endif
  au BufWritePost *.bin,*.img,*.wav,*.pcm,*.raw if &bin | %!xxd
  au BufWritePost *.bin,*.img,*.wav,*.pcm,*.raw set nomod | endif
augroup END
" }}}

" Smooth Scrolling {{{
" this leaves the cursor on the same line as apposed to before where it moves
" the cursor.
map <C-U> <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>
map <C-D> <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
" }}}
"
" modeline {{{
set modelines=1   " turn on vim settings that will be read from the last line
" example:
" vim:foldmethod=marker:foldlevel=0
" python: (remember space after #)
" # vim: tabstop=2 expandtab shiftwidth=2 softtabstop=2
" }}}

" ctags {{{
" ctags - look in the current directory for 'tags',
" and work up the tree towards root until one is found
set tags=./.tags;/

" open tag
" map <silent> <F3> <c-]>
" open tag in vertical split
map <silent> <F3> <c-]> <bar> :execute 'normal zt'<cr>
" previous
" map <silent> <A-Left> <c-t>
" }}}

" {{{
" force open open file
map <leader>gf :e <cfile><cr>
" }}}

" toggle file {{{
function! s:SpookyMirrorFor(file, match, dest) abort
  " echo "'".a:file."'".a:match."'"
  " echo a:match
  let lres = matchlist(a:file, a:match)
  let res = matchstr(a:file, a:match)
  " echo res
  if !empty(res)
    for cur in a:dest
      let i=1
      while i < len(lres)
        " echo "substitute(".cur.", \\".i.", ".get(lres, i).", \"\")"
        let cur = substitute(cur,'\\'.i , get(lres, i), "g")
        let i += 1
      endwhile
      " echo cur
      if filereadable(cur)
        return cur
      endif
    endfor
  endif

  return ""
endfunction

function! s:SpookyGetMirror(file) abort
  " let fname='\w\+'
  let fname='[a-zA-Z0-9_-]\+'
  " echo a:file

  " if s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.vim$', ['\1/\2.cpp'])
  "   return 0
  " endif

  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/lib\/\('.fname.'\)\.c$', ['\1/include/linux/\2.h'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/kernel\/\('.fname.'\)\.c$', ['\1/include/linux/\2.h'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/linux\/\('.fname.'\)\.h$', ['\1/kernel/\2.c', '\1/lib/\2.c'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " /src/fname.[c, cc, cpp] -> /[include, inc, '']/fname.[h, hh, hpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/src\/\('.fname.'\)\.c$', ['\1/include/\2.h', '\1/inc/\2.h', '\2.h'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/src\/\('.fname.'\)\.cc$', ['\1/include/\2.h', '\1/inc/\2.h', '\2.h', '\1/include/\2.hh', '\1/inc/\2.hh', '\2.hh', '\1/include/\2.hpp', '\1/inc/\2.hpp', '\2.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/src\/\('.fname.'\)\.cpp$', ['\1/include/\2.h', '\1/include/\2.hpp', '\1/include/\2.hh', '\1/inc/\2.h', '\1/inc/\2.hpp', '\1/inc/\2.hh'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " /source/fname.[c, cc, cpp] -> /[include, inc, '']/fname.[h, hh, hpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/source\/\('.fname.'\)\.c$', ['\1/include/\2.h', '\1/inc/\2.h', '\2.h'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/source\/\('.fname.'\)\.cc$', ['\1/include/\2.h', '\1/inc/\2.h', '\2.h', '\1/include/\2.hh', '\1/inc/\2.hh', '\2.hh', '\1/include/\2.hpp', '\1/inc/\2.hpp', '\2.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/source\/\('.fname.'\)\.cpp$', ['\1/include/\2.h', '\1/include/\2.hpp', '\1/include/\2.hh', '\1/inc/\2.h', '\1/inc/\2.hpp', '\1/inc/\2.hh'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " /include/fname.[h, hh, hpp] -> [src, source]/fname.[c, cc, cpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\('.fname.'\)\.h$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\('.fname.'\)\.hh$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\('.fname.'\)\.hpp$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " /inc/fname.[h, hh, hpp] -> [src, source, '']/fname.[c, cc, cpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\('.fname.'\)\.h$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\('.fname.'\)\.hh$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\('.fname.'\)\.hpp$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " fname.[cpp,cc,c] -> [include, inc, '']/fname.[h,hpp,hh]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.cpp$', ['\1/\2.h', '\1/\2.hpp', '\1/\2.hh', '\1/include/\2.h', '\1/include/\2.hpp', '\1/include/\2.hh', '\1/inc/\2.h', '\1/inc/\2.hpp', '\1/inc/\2.hh'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.cc$', ['\1/\2.h', '\1/\2.hpp', '\1/\2.hh', '\1/include/\2.h', '\1/include/\2.hpp', '\1/include/\2.hh', '\1/inc/\2.h', '\1/inc/\2.hpp', '\1/inc/\2.hh'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.c$', ['\1/\2.h', '\1/include/\2.h', '\1/inc/\2.h'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " fname.[h,hpp,hh] -> fname.[cpp,c,cc]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.h$', ['\1/\2.cpp', '\1/\2.c', '\1/\2.cc'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.hpp$', ['\1/\2.cpp', '\1/\2.cc'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.hh$', ['\1/\2.cpp', '\1/\2.cc'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

" /proj/src/fname.[c, cc, cpp] -> /proj/[include, inc]/proj/fname.[h, hh, hpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/src\/\('.fname.'\)\.c$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/src\/\('.fname.'\)\.cc$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/src\/\('.fname.'\)\.cpp$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

" /proj/source/fname.[c,cc,cpp] -> /proj/[include, inc]/proj/fname.[h, hh, hpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/source\/\('.fname.'\)\.c$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/source\/\('.fname.'\)\.cc$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/source\/\('.fname.'\)\.cpp$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

"  /proj/include/proj/fname.[h, hh, hpp] -> /proj/[source, src]/fname.[c,cc,cpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\(.*\)\/\('.fname.'\)\.h$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\(.*\)\/\('.fname.'\)\.hh$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\(.*\)\/\('.fname.'\)\.hpp$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

"  /proj/inc/proj/fname.[h, hh, hpp] -> /proj/[source, src]/fname.[c,cc,cpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\(.*\)\/\('.fname.'\)\.h$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\(.*\)\/\('.fname.'\)\.hh$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\(.*\)\/\('.fname.'\)\.hpp$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  return ""
endfunction

function! s:SpFindGit(path) abort
  let l:parent = a:path

  while 1
    let l:path = l:parent . '/.git'
    if isdirectory(l:path) || filereadable(l:path)
      return l:parent
    endif
    let l:next = fnamemodify(l:parent, ':h')
    if l:next == l:parent
      return ''
    endif
    let l:parent = l:next
  endwhile
endfunction

function! s:SpFindFile(root, needles, ignores) abort
  " find . -type f \( -name "xxx.h" -o -name "xxx.hh" \)
  let l:first = 1
  if len(a:needles) == 0
    return []
  endif

  if !executable('find')
    return []
  endif

  let l:cmd = "find ".a:root." -type f \\("
  for l:needle in a:needles
    if l:first == 0
      let l:cmd .= " -o " " or
    endif
    let l:cmd .= " -name '".l:needle."'"
    let l:first = 0
  endfor
  let l:cmd .= " \\)"
  for l:ignore in a:ignores
    let l:cmd .= " -not -path '*/".l:ignore."/*'"
  endfor
  " echomsg l:cmd
  let l:result = systemlist(l:cmd)
  " echomsg v:shell_error
  " echomsg l:result
  if v:shell_error == 0
    return l:result
  endif

  return []
endfunction


function s:FuncPreview()
  " https://vim.fandom.com/wiki/Quick_reference_of_current_function
  let l:opening = search("^\\S.*)\\s*\\\(\\n\\\)\\={","bn")
  let l:closing = search("^}","bn")
  if l:opening > l:closing
    return '    '.getline(l:opening)
  else
    return ""
  endif
endfunction

function! s:SpookyLimitMsgLength(msg, strip_prefix) abort
  let l:win_width = winwidth(0)-30
  let l:limit = l:win_width < 0 ? 0 : l:win_width
  let l:msg_len = strlen(a:msg)
  if l:msg_len > l:limit
    if a:strip_prefix == 1
      let l:start = l:msg_len-l:limit
      return a:msg[l:start:]
    else
      return a:msg[:l:limit]
    endif
  endif
  return a:msg
endfunction

function! s:SpookyPrintCurrentFile() abort
  let l:strip_prefix = 1
  " redraw
  " escape: Escape the characters in {chars} that occur in {string} with a
  " example: :echo escape('c:\program files\vim', ' \')
  " results in: 'c:\\program\ files\\vim'
  let l:self = expand("%:p")
  let l:parent = expand('%:p:h') " escape()
  let l:git = s:SpFindGit(parent)
  if l:git !=# ''
    let l:self = l:self[len(l:git)+1:len(l:self)]
  endif

  if &ft == "c"
    let l:win_width = winwidth(0)-30
    let l:limit = l:win_width < 0 ? 0 : l:win_width
    if strlen(l:self) < l:limit
      let l:strip_prefix = 0
      let l:self = l:self . s:FuncPreview()
    endif
  endif
  echomsg s:SpookyLimitMsgLength(l:self, l:strip_prefix)
" echo fnameescape(fnamemodify(finddir('.git',escape(expand('%:p:h'), ' ') . ';'), ':h'))

endfunction

function! s:SpookyToggleFile(fpath, fname, fext) abort
  if !exists("g:sp_toggle_file")
    let g:sp_toggle_file = {}
  endif
  if !exists("g:sp_cached_mirror")
    " cache so that we are not required to repeatedly have to re:find mirror
    let g:sp_cached_mirror = {}
  endif

  let l:mirror = s:SpookyGetMirror(a:fpath)
  if strlen(l:mirror) == 0
    " fallback: we use Linux "find" util to find mirror
    if has_key(g:sp_cached_mirror, a:fpath)
      let l:mirror = g:sp_cached_mirror[a:fpath]
    else
      let l:git_root = s:SpFindGit(a:fpath)
      if strlen(l:git_root) > 0
        let l:ignores =  ['stub','testing','checktest','checktests','tests','test','test-support','examples']
        let l:candidates = []
        if a:fext == "c"
          let l:candidates = s:SpFindFile(l:git_root, [a:fname.'.h'], l:ignores)
        elseif a:fext == "cc" || a:fext == "cpp"
          let l:candidates = s:SpFindFile(l:git_root, [a:fname.'.h', a:fname.'.hh', a:fname.'.hpp'], l:ignores)
        elseif a:fext == "hh" || a:fext == "hpp" || a:fext == "h"
          let l:candidates = s:SpFindFile(l:git_root, [a:fname.'.c', a:fname.'.cc', a:fname.'.cpp'], l:ignores)
        endif
        if len(l:candidates) > 0
          let l:mirror = l:candidates[0] " just get the first result
          " cache mirrors:
          let g:sp_cached_mirror[a:fpath] = l:mirror
          let g:sp_cached_mirror[l:mirror] = a:fpath
        endif
      endif
    endif
  endif

  if strlen(l:mirror) > 0
    let g:sp_toggle_file[a:fpath] = winsaveview()
    execute "silent edit ".l:mirror
    if has_key(g:sp_toggle_file, l:mirror)
      call winrestview(g:sp_toggle_file[l:mirror])
    endif
    call s:SpookyPrintCurrentFile()
  endif
endfunction

" autocmd FileType c,cpp
command! SpookyToggleFile :call s:SpookyToggleFile(expand('%:p'), expand('%:t:r'), expand('%:e'))
augroup AugroupToggleFIle
  autocmd!
  autocmd FileType c,cpp nnoremap <silent> <F2> :SpookyToggleFile<CR>
augroup END
" }}}

" {{{
function! s:SpookyHeaderType(file) abort
  let l:mirror = s:SpookyGetMirror(a:file)
  if strlen(l:mirror) > 0
    if l:mirror =~ '\.cpp$' || l:mirror =~ '\.cc$'
      set ft=cpp
      return 1
    endif
  endif

  set ft=c
  return 1
endfunction

function! s:SpookySetSpaceIdent() abort
  setlocal listchars+=tab:·»
  setlocal expandtab       " <tab> is converted to spaces
  setlocal tabstop=2       " Number of spaces that a <Tab> in the file counts for
  setlocal shiftwidth=2    " number of spaces to use for autoindenting
endfunction

function! s:SpookyIndentDetect() abort
" 'vim-plug', '', 'gitcommit', 'tagbar'
  if &buftype ==# 'help'
    return
  endif
  " echomsg "spooky: ".expand('%')

  let heuristics = {'spaces': 1, 'tabs': 0}
  let lines = getline(1, 1024)
  " echomsg "lines: ".len(lines)."|".get(lines, 0, "NONE")."|".len(get(lines, 0, "NONE"))

  for line in lines
    " echomsg line
    if len(line) == 0
      continue
    endif

    " line only containing spaces
    if line =~# '^ *$'
      continue
    endif
    " line only containing tabs
    if line =~# '^\t*$'
      continue
    endif

    " c style multiline comment
    " /*
    " _*/
    if line =~# '^ \*'
      continue
    endif


    if line =~# '^\t'
      let heuristics.tabs += 1
    elseif line =~# '^ '
      let heuristics.spaces += 1
    endif

  endfor

  " set noexpandtab
  " set expandtab                     " <tab> is converted to spaces
  " set shiftwidth=2                  " number of spaces to use for autoindenting
  set smarttab                        " insert tabs on the start of a line according
                                      " to shiftwidth, not tabstop
  " TODO rust indent with two tabs
  " echo "tabs:".heuristics.tabs." spaces:".heuristics.spaces
  if heuristics.tabs > heuristics.spaces
    " echomsg "hard! tabs:".heuristics.tabs." spaces:".heuristics.spaces
    setlocal noexpandtab
    setlocal tabstop=2
    setlocal shiftwidth=2
  else " if heuristics.spaces > heuristics.tabs
    " echomsg "spaces! tabs:".heuristics.tabs." spaces:".heuristics.spaces
    call s:SpookySetSpaceIdent()
  endif
endfunction

call s:SpookySetSpaceIdent()
augroup AutogroupIndentDetect
  autocmd!
  autocmd BufReadPost,FileReadPost * call s:SpookyIndentDetect()
  " autocmd FileType call s:SpookyIndentDetect()
augroup END

augroup AutogroupFileSpecific
  autocmd!

  " manually set filetype based on ext
  autocmd BufNewFile,BufFilePre,BufRead *.md set ft=markdown
  autocmd BufNewFile,BufFilePre,BufRead *.vertexshader set ft=glsl
  autocmd BufNewFile,BufFilePre,BufRead *.fragmentshader set ft=glsl
  " https://github.com/Shirk/vim-gas
  autocmd BufNewFile,BufRead *.nasm set ft=nasm
  autocmd BufNewFile,BufRead *.fpp set ft=sh

  " type specific settings
  autocmd FileType markdown setlocal ts=2 sw=2 expandtab
  autocmd FileType markdown,text,mail,tex setlocal textwidth=80
  autocmd FileType gitcommit setlocal textwidth=72
  autocmd FileType gitcommit,markdown,text,mail,tex setlocal colorcolumn=-1   " display bar at textwidth
  autocmd FileType gitcommit,markdown,text,mail setlocal complete+=kspell
" enable spelling for these types
  autocmd FileType gitcommit,mail setlocal spell

  " set file type for files without extension like <atomic>
  autocmd BufRead,BufNewFile /usr/include/c++/* set ft=cpp
  autocmd BufRead,BufNewFile /usr/lib/gcc/* set ft=cpp
  autocmd BufRead,BufNewFile Kbuild.include set ft=make

  "
  autocmd BufNewFile,BufFilePre,BufRead *.h call s:SpookyHeaderType(expand('%:p'))
augroup END
" }}}

"nnoremap
" map <silent> gt :tabnext <bar> redraw <bar> echo @%<cr>
" nnoremap <expr> gt :tabnext v:count <bar> redraw <bar> echo @%<cr>
" function! s:SpookyTabPriv() abort
"   tabprevious
"   call s:SpookyPrintCurrentFile()
" endfunction
" command! SpookyTabPriv :call s:SpookyTabPriv()
"
" nmap <silent> gT :SpookyTabPriv<cr>
" " map <silent> gT :tabprevious <bar> redraw <bar> echo @%<cr>
"
" function! SpookyTabNext(cnt) abort
"   " echomsg " tabpagenr():".tabpagenr()." a:cnt:".a:cnt
"   if a:cnt > 0
"     " echomsg " tabpagenr():".tabpagenr()." a:cnt:".a:cnt
"     if tabpagenr() == a:cnt
"       return
"     endif
"     execute "tabnext ".a:cnt
"   else
"     tabnext
"   endif
"   call s:SpookyPrintCurrentFile()
" endfunction
"
" nmap <silent> gt :<C-U>call SpookyTabNext(v:count)<cr>
augroup AutogroupPrintCurrentTab
    autocmd!
    autocmd TabEnter * call s:SpookyPrintCurrentFile()
    " autocmd BufEnter * call s:SpookyPrintCurrentFile()
augroup END

" set laststatus=2
" set statusline+=%F
"
" nnoremap <expr> - (v:count > 3 ? "m'" . v:count : '') . '-'

function! s:SpMathFormat() range
  function! s:Xx(str)
    let l:result = ""
    let l:state = 0
    let l:del = { 'cnt': 0, 'mem': '', 'inzert':'', 'cmp':'' }
    let l:sub_sup = { 'cnt': 0 } " to support alone: _ ^
    let l:open_brace_cnt=0 " pairing up () or returning to state:0

    let l:complex = { '(xor)': '⊕', '(pi)': 'π', '(integral)': '∫', '(mul)': '∏',
                    \ '(qed)': '∎', '(element)': '∊' , '(not)': '¬', '(theta)': 'θ', '(lambda)': 'λ',
                    \ '(alpha)': 'α', '(phi)': 'φ', '(phi2)': 'ϕ', '(proportional)': '∝', '(gamma)': 'Γ', '(_gamma)': '𝛾', '(mu)':'μ',
                    \ '(sigma)': '∑', '(_sigma)': 'σ', '(omega)': 'Ω', '(_omega)': 'ω', '(sqrt)': '√', '(epsilon)': 'ε',
                    \ '(beta)': 'Β', '(_beta)': 'β',
                    \ '(micro)': 'µ', '(infinity)': '∞', '(inf)': '∞', '(f)': 'ƒ', '(frequency)': 'ƒ',
                    \ '(almost)': '≈', '(aprox)': '≈', '(delta)': 'Δ', '(_delta)': 'δ',
                    \ '(_ny)': 'ν', '(member)': '∈', '(angle)': '∠', '(_tau)': 'τ', '(tau)': 'Τ',
                    \ '(prime)': 'ℙ', '(natural)': 'ℕ', '(integer)': 'ℤ', '(rational)': 'ℚ', '(real)': 'ℝ', '(FF)': '𝔽', '(ZZ)': 'ℤ',
                    \ '(forall)': '∀', '(z)':'ƶ', '(Z)':'Ƶ', '=>':'⇒', '==>': '⟹',
                    \ '(1/4)': '¼', '(1/2)': '½', '(3/4)': '¾', '(1/7)': '⅐', '(1/9)': '⅑', '(1/3)': '⅓',
                    \ '(2/3)': '⅔', '(1/10)': '⅒', '(1/5)': '⅕', '(2/5)': '⅖', '(3/5)':'⅗', '(4/5)': '⅘',
                    \ '(1/6)': '⅙', '(5/6)':'⅚', '(1/8)': '⅛', '(3/8)':'⅜', '(5/8)': '⅝', '(7/8)': '⅞',
                    \ '(1/)': '⅟', '(0/3)': '↉', '(congruent)': '≡',
                    \ '(<--)': '⟵', '(-->)': '⟶', '(<-->)': '⟷', '(<==)': '⟸', '(==>)': '⟹', '(<==>)': '⟺',
                    \ '(^\)': '↖', '(/^)': '↗', '(\V)': '↘', '(V/)': '↙',
                    \ '(<=)': '⇐', '(^=)': '⇑', '(=>)': '⇒', '(V=)': '⇓', '(<=>)': '⇔', '(V=^)': '⇕', '(^=V)': '⇕',
                    \ '(<-)': '←', '(|^)': '↑', '(^|)': '↑', '(^)': '↑', '(->)': '→', '(V)': '↓', '(<>)': '↔', '(^V)': '↕', '(V^)': '↕', '(^|V)': '↕', '(V|^)': '↕',
                    \ '(union)': '∪', '(intersect)': '∩', '(empty)': '∅', '(F)': '𝓕',
                    \ '(tick)': '✓', '(untick)': '✗', '(AC)': '⏦', '(degree)': '°', '(degrees)': '°'}
    let l:complex_mem = {'index': 0, 'candidates': deepcopy(l:complex), 'memory': ''}

    for l:char in split(a:str, '\zs')
      if l:state == 1 " ^ (superscript)
        let l:dict = {  '0': '⁰', '1': '¹', '2': '²', '3': '³', '4': '⁴', '5': '⁵',
                       \ '6': '⁶', '7': '⁷', '8': '⁸', '9': '⁹', 'i': 'ⁱ', 'a': 'ᵃ',
                       \ 'b': 'ᵇ', 'c': 'ᶜ', 'd': 'ᵈ', 'e': 'ᵉ', 'f': 'ᶠ', 'g': 'ᵍ',
                       \ 'h': 'ʰ', 'k': 'ᵏ', 'l': 'ˡ', 'm': 'ᵐ', 'n': 'ⁿ', 'o': 'ᵒ',
                       \ 'p': 'ᵖ', 'q': '𐞥', 'r': 'ʳ', 's': 'ˢ', 't': 'ᵗ', 'u': 'ᵘ', 'v': 'ᵛ',
                       \ 'w': 'ʷ', 'x': 'ˣ', 'y': 'ʸ', 'z': 'ᶻ', 'j': 'ʲ',
                       \ '+': '⁺', '−': '⁻', '-': '⁻', '(': '⁽', ')': '⁾', 'A': 'ᴬ', 'B': 'ᴮ', 'C': 'ꟲ',
                       \ 'D': 'ᴰ', 'E': 'ᴱ', 'F': 'ꟳ', 'G': 'ᴳ', 'H': 'ᴴ', 'I': 'ᴵ', 'J': 'ᴶ',
                       \ 'K': 'ᴷ', 'L': 'ᴸ', 'M': 'ᴹ', 'N': 'ᴺ', 'O': 'ᴼ', 'P': 'ᴾ', 'Q': 'ꟴ', 'R': 'ᴿ',
                       \ 'T': 'ᵀ', 'U': 'ᵁ', 'V': 'ⱽ', 'Z': 'ᶻ', '/': '/', 'θ':'ᶿ',
                       \ 'Β': 'ᵝ', 'Θ': 'ᶿ', 'Φ': 'ᵠ', 'Χ': 'ᵡ'}

        let l:default = 'a'
        let l:super = get(l:dict, l:char, l:default)
        if l:super == l:default
          if l:sub_sup.cnt == 0
            let l:result = l:result.'^'
          endif
          let l:state = 0
          let l:open_brace_cnt = 0
          let l:sub_sup = { 'cnt': 0 }
        else
          if l:char == '('
            let l:open_brace_cnt += 1
          endif
          if l:char == ')'
            if l:open_brace_cnt > 0
              let l:open_brace_cnt -= 1
            else
              let l:state = 0
              let l:open_brace_cnt = 0
              let l:sub_sup = { 'cnt': 0 }
            endif
          endif
        endif

        if l:state == 1 " ^
          let l:sub_sup.cnt += 1
          let l:result = l:result.l:super
        endif
      endif

      if l:state == 2 " _ (subscript)
        let l:dict = { '0': '₀', '1': '₁', '2': '₂', '3': '₃', '4': '₄',
                    \ '5': '₅', '6': '₆', '7': '₇', '8': '₈', '9': '₉',
                    \ 'a': 'ₐ', 'e': 'ₑ', 'o': 'ₒ', 'h': 'ₕ', 'k': 'ₖ',
                    \ 'l': 'ₗ', 'm': 'ₘ', 'p': 'ₚ', 's': 'ₛ', 't': 'ₜ',
                    \ 'n': 'ₙ', 'i': 'ᵢ', 'y': 'ᵧ', 'x': 'ₓ', 'j': 'ⱼ', 'ǝ': 'ₔ', 'r': 'ᵣ', 'u': 'ᵤ', 'v': 'ᵥ',
                    \ '+': '₊', '-' :'₋', '(': '₍', ')': '₎', '=': '₌',
                    \ 'Β': 'ᵦ', 'Γ': 'ᵧ', 'Ρ':'ᵨ', 'Φ': 'ᵩ', 'Χ': 'ᵪ'}

        let l:default = 'a'
        let l:sub = get(l:dict, l:char, l:default)
        if l:sub == l:default
          if l:sub_sup.cnt == 0
            let l:result = l:result.'_'
          endif
          let l:state = 0
          let l:sub_sup = { 'cnt': 0 }
        else
          if l:char == '('
            let l:open_brace_cnt += 1
          endif
          if l:char == ')'
            if l:open_brace_cnt > 0
              let l:open_brace_cnt -= 1
            else
              let l:state = 0
              let l:open_brace_cnt = 0
              let l:sub_sup = { 'cnt': 0 }
            endif
          endif

          if l:state == 2 " _
            let l:sub_sup.cnt += 1
            let l:result = l:result.l:sub
          endif
        endif
      endif

      if l:state == 3 " del +-: ±
        if l:char == l:del.cmp
          let l:del.cnt -= 1
          let l:del.mem .= l:char
          if l:del.cnt == 0
            let l:result = l:result.l:del.inzert
            let l:del = { 'cnt': 0, 'mem': '', 'inzert':'', 'cmp':'' }
            let l:state = 4 " skip
          endif
        else " do not match so add memory
          let l:result = l:result.l:del.mem
          let l:del = { 'cnt': 0, 'mem': '', 'inzert':'', 'cmp':'' }
          let l:state = 0
        endif
      endif

      if l:state == 5 " example: (xor)
        for [l:key, l:value] in items(l:complex_mem.candidates)
          if strlen(l:key) < strlen(l:complex_mem.memory)
            call remove(l:complex_mem.candidates, l:key)
          else
            if l:key[strlen(l:complex_mem.memory)] !=# l:char
              call remove(l:complex_mem.candidates, l:key)
            else
              let l:tmp_key=l:key
              let l:tmp_value=l:value
            endif
          endif
        endfor

        if len(l:complex_mem.candidates) == 0
          let l:result = l:result.l:complex_mem.memory
          let l:state = 0
          let l:complex_mem = {'index': 0, 'candidates': deepcopy(l:complex), 'memory': ''}
        elseif len(l:complex_mem.candidates) == 1 && strlen(l:tmp_key) == strlen(l:complex_mem.memory)+1
          let l:tmp = l:complex_mem.memory.l:char
          if l:tmp_key ==# l:tmp
            let l:result = l:result.l:tmp_value
            let l:state = 4 " skip
          else
            let l:result = l:result.l:complex_mem.memory
            let l:state = 0
          endif
          let l:complex_mem = {'index': 0, 'candidates': deepcopy(l:complex), 'memory': ''}
        else
          let l:complex_mem.memory .= l:char
        endif
      endif

      if l:state == 0
        if l:char == '_'
          let l:state = 2
        elseif l:char == '^'
          let l:state = 1
        elseif l:char == '*'
          let l:result = l:result.'⋅'
        elseif l:char == '.'
          let l:state = 3 " del
          let l:del.cmp = '.'
          let l:del.cnt = 2
          let l:del.inzert = '…'
          let l:del.mem = l:char
        elseif l:char == '+'
          let l:state = 3 " del
          let l:del.cmp = '-'
          let l:del.cnt = 1
          let l:del.inzert = '±'
          let l:del.mem = l:char
        elseif l:char == '!'
          let l:state = 3 " del
          let l:del.cmp = '='
          let l:del.cnt = 1
          let l:del.inzert = '≠'
          let l:del.mem = l:char
        elseif l:char == '>'
          let l:state = 3 " del
          let l:del.cmp = '='
          let l:del.cnt = 1
          let l:del.inzert = '≥'
          let l:del.mem = l:char
        elseif l:char == '<'
          let l:state = 3 " del
          let l:del.cmp = '='
          let l:del.cnt = 1
          let l:del.inzert = '≤'
          let l:del.mem = l:char
        elseif l:char == '('
          let l:state = 5 "
          let l:complex_mem.memory = l:char
        else
          let l:result = l:result.l:char
          " echomsg '-'.l:char
        endif
      endif

      " echomsg '['.l:char.']:'.l:state.'"'.l:result.'"'
      if l:state == 4 " skip"
        let l:state = 0
      endif

    endfor

    if l:state == 1 " ^
      if l:sub_sup.cnt == 0
        let l:result = l:result.'^'
      endif
    endif
    if l:state == 2 "_
      if l:sub_sup.cnt == 0
        let l:result = l:result.'_'
      endif
    endif
    if l:state == 3 " del
      let l:result = l:result.l:del.mem
    endif

    if l:state == 5 " (xor)
      let l:result = l:result.l:complex_mem.memory
    endif

    return l:result
  endfunction

  let [l:line_start, l:col_start] = getpos("'<")[1:2]
  let [l:line_end, l:col_end] = getpos("'>")[1:2]
  let l:lines = range(line_start, line_end)

  for l:lit in l:lines
    let l:str_line = getline(l:lit)
    let l:cs = 0
    let l:ce = strlen(l:str_line)
    let l:whole_line = 1

    if l:lit == l:line_start
      let l:cs = l:col_start-1
      let l:whole_line = 0
    endif
    if l:lit == l:line_end
      let l:ce = l:col_end-1
      let l:whole_line = 0
    endif

    if l:whole_line == 0
      " echo ":".l:ce
      let l:ln = l:str_line[l:cs : l:ce]
      " echo "|".l:ln."|"
    else
      let l:ln = l:str_line
    endif
    let l:enhanced_line = s:Xx(l:ln)
    if l:whole_line == 0
      " echo 0."|".l:str_line[0: l:cs]."|".l:cs
      let l:prefix=""
      if l:cs != 0
        let l:prefix=l:str_line[0: l:cs-1]
      endif

      " echomsg "|".l:prefix."|".l:enhanced_line."|".l:str_line[l:ce+1: -1]."|"
      call setline(l:lit, l:prefix.l:enhanced_line.l:str_line[l:ce+1: -1])
    else
      " echomsg "[".l:enhanced_line."]"
      call setline(l:lit, l:enhanced_line)
    endif

    " echo l:whole_line."|".l:ln
  endfor

  " set cursor at start of selection
  call cursor(l:line_start,l:col_start)

  "                        line
  "                      __|_  __column__
  " whole line start [0, 1464, 1         , 0]
  " while line end   [0, 1466, 2147483647, 0]
  " echo getpos("'<")
  " echo getpos("'>")
  " echo l:line_start. " ".l:line_end
  " echo l:col_start. " ".l:col_end

  " fun! s:replace_in_line(lnum, col_start, col_end, item)
  " let l:curline = getline(a:lnum)
  " let l:newline = l:curline[0: a:col_start] . a:item . l:curline[a:col_end: -1]
  " call setline(a:lnum, l:newline)
  " endfun
  " TODO:
  " (n)     ⎛n⎞
  " ( ) =   ⎜ ⎟
  " (k)     ⎝k⎠
  " TODO -+-- should not be translated to -±-
endfunction
command! -range SpMathFormat <line1>,<line2>call s:SpMathFormat()
xnoremap <leader>m <Esc>:SpMathFormat<CR>


function! s:SpookyToString()
  let l:exe = 'sp_struct_to_string'
  if executable(l:exe)
    let l:file = expand('%:p')
    let l:line = line('.')-1
    let l:col = col('.')-1
    " echo l:exe." line ".l:file." ".l:line." ".l:col." 2>/dev/null"
    let l:append_line = system(l:exe." line ".l:file." ".l:line." ".l:col." 2>/dev/null")
    if v:shell_error == 0
      let l:fun = system(l:exe." crunch ".l:file." ".l:line." ".l:col." 2>/dev/null")
      " echomsg l:fun
      if v:shell_error == 0
        call append(l:append_line, split(l:fun, "\n"))
      else
        echo "error1: ".v:shell_error
      endif
    else
      echo "error0: ".v:shell_error
    endif
  endif
endfunction

function! s:SpookyToStringLocals()
  let l:exe = 'sp_struct_to_string'
  if executable(l:exe)
    let l:file = expand('%:p')
    let l:line = line('.')-1
    let l:col = col('.')-1
    " echo l:exe." line ".l:file." ".l:line." ".l:col." 2>/dev/null"
    let l:append_line = system(l:exe." locals ".l:file." ".l:line." ".l:col." 2>/dev/null")
    if v:shell_error == 0
      call append(l:line+1, split(l:append_line, "\n"))
    else
      echo "error0: ".v:shell_error
    endif
  endif
endfunction

command! SpookyToString call s:SpookyToString()
command! SpookyToStringLocals call s:SpookyToStringLocals()
augroup AugroupToString
  autocmd!
  autocmd FileType c,cpp noremap <leader>m <Esc>:SpookyToString<CR>
  autocmd FileType c,cpp noremap <leader>l <Esc>:SpookyToStringLocals<CR>
augroup END
