" Turn off vi compatibility.(sould be set first)
set nocompatible

" always show tab bar
set showtabline=2
" the limit of the number of files opened by vim -p
set tabpagemax=100

" {{{
" shorter info messages
set shortmess=flmnrwI
" }}}

" encoding {{{
set encoding=utf-8      " The encoding used
set fileencoding=utf-8  " The encoding of the resulting output file
scriptencoding utf-8
" }}}

if has('gui_running')
  " configure font and font size for gvim
  " set guifont=Consolas:h9

  " a gui pops up allowing you to configure font, size...
  " set guifont=*
endif

" if $TERM == "xterm-256color"
" endif

function! s:IsWSL()
  let lines = substitute(system('uname -a'),'\n','','')
  if lines =~ "Microsoft"
    return 1
  endif
  return 0
endfunction

if s:IsWSL()
  " somewhat fixes the bugged backgound in WSL+alacritty+vim
  set t_ut=
endif

if $TERM == "alacritty" || $TERM == "xterm-256color" || $TERM == "screen-256color" || $COLORTERM == "gnome-terminal" || $TERM == "urxvt" || $TERM == "tmux-256color" || has('nvim')
  set t_Co=256
  if has('nvim') || has('termguicolors')
    " :h xterm-true-color
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    " :h termguicolors
    " guibg and guifg are defined also in terminal Vim used by colorscheme
    set termguicolors
  endif
endif

silent! colorscheme codedark

if v:version > 703 || v:version == 703 && has('patch541') || has('nvim')
  " Fixes joining comment lines
  set formatoptions+=j
endif

"
filetype on                       " Enable file type detection
filetype plugin on                " Enable file type plug-ins
filetype indent plugin on         " file type specific indentation support + loading language indentation specific files

" General {{{
let mapleader = "\<Space>"        " map leader to  <space>
if has('nvim')
else
  set pastetoggle=<f5>              " vim will not perform any formatting when toggled on
endif
" }}}
" Mouse {{{
set mouse=                        " Disable mouse interaction
" set mouse=a                     " Enables scrolling terminal.(mouse mode)
" }}}
" UI {{{
set ruler                         " Display the ruler
set showcmd                       " Show incomplete vim motions as I type
set relativenumber                " Relative line numbers
set number                        " Relative + Absolute number
set lazyredraw                    " don't bother updating screen during macro playback
" set showmatch                     " blink matching [{()}] on insert
set title                         " change the terminal's title

set novisualbell                  " don't beep
set noerrorbells                  " don't beep

set splitright                    " open new pane to the right

set scrolloff=1                   " keep at least N lines above/below when scrolling

" if !has('win32unix') && !has('win64unix')
  " does not work in cygwin
  " set ttyfast                     " Faster redraw
" endif

" Highlight current line
" Enable cursorline only on the active buffer
augroup AutogroupCursorLine
    "https://stackoverflow.com/a/12018552
    autocmd!
    autocmd VimEnter,WinEnter,BufWinEnter * setlocal cursorline
    autocmd WinLeave * setlocal nocursorline
augroup END

" no top level buffer is displayed when using autosggestion
set completeopt-=preview
" }}}

" syntax {{{
syntax enable                     " Highlight the syntax.
" }}}

" folding {{{
set nofoldenable                  " disable folding
" }}}

" gvim {{{
" hide all gui
set guioptions=
" }}}

" command(:) {{{
set history=1000                 " remember more commands and search history
set wildmode=longest:full,full   " bash like command(:) completion when tab
set wildmenu                     " Show command(:) completion with tab

" Suffixes that get lower priority when doing tab completion for filenames.
" These are files we are not likely to want to edit or read.
set suffixes=.bak,~,.swp,.o,.info,.aux,.log,.dvi,.bbl,.blg,.brf,.cb,.ind,.idx,.ilg,.inx,.out,.toc,.png,.jpg

" ignore these files when :edit <tab>
set wildignore=*.swp,*.bak,*.pyc,*.exe,*.dat,*.bin,*.out,*.pdf,*.cache,*.part
set wildignore+=*.tmp
set wildignore+=*.d,main,*.o,*.a,*.stackdump,*.so
set wildignore+=*.bmp,*.gif,*.ico,*.jpg,*.png,*.mkv,*.mp4
set wildignore+=*.class,*.jar
set wildignore+=*.zip,*.tar,*.tar.gz
set wildignore+=GPATH,GRTAGS,GTAGS
" TODO does not work
set wildignore+=*~

set wildignore+=*/node_modules/*
set wildignore+=*/tmp/*
set wildignore+=*/target/*
set wildignore+=*/build/*

set wildignore+=*/.git,*/.hg,*/.svn
set wildignore+=tags,*.tags

set wildignore+=external/googletest/*
set wildignore+=*external/googletest/*
set wildignore+=*/external/googletest/*

set wildignore+=external/googletest*
set wildignore+=*external/googletest*
set wildignore+=*/external/googletest*

set wildignore+=external/googletest
set wildignore+=*external/googletest
set wildignore+=*/external/googletest

set wildignore+=external/googletest/
set wildignore+=*external/googletest/
set wildignore+=*/external/googletest/

set wildignore+=external/googletest/**
set wildignore+=*external/googletest/**
set wildignore+=*/external/googletest/**

set wildignore+=external/googletest**
set wildignore+=*external/googletest**
set wildignore+=*/external/googletest**
"","build/**","build_test/**"
" let g:CommandTWildIgnore=&wildignore . ",external/googletest/**"

" set wildignore+=
" }}}


augroup AutogroupRememberFilePosition
  autocmd!
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif
augroup END

if has('win32unix') || has('win64unix')
  " cursor shape
  " https://github.com/mintty/mintty/wiki/Tips
  let &t_ti ="\e[1 q"           " put terminal in termcap mode
  let &t_SI ="\e[5 q"           " Start insert mode
  let &t_EI ="\e[1 q"           " End insert or replace mode
  let &t_te ="\e[0 q"           " out of termcap mode

  let &t_ti ="\e[?7727h"
  let &t_te ="\e[?7727l"
  " noremap <Esc>O[ <Esc>
  " noremap! <Esc>O[ <C-c>
else
  " alacritty cursor shape settings does not work inside tmux
  let &t_SI = "\<Esc>[6 q" " pipe
  let &t_SR = "\<Esc>[4 q" " underline
  let &t_EI = "\<Esc>[0 q" " block
endif

" ttimout ==keycode timeout
" timout == mapping timeout
" Get rid of nasty lag on ESC (timeout and ttimeout seem useless) sp??
augroup AutogroupEscapeLag
  autocmd!
  au InsertEnter * set timeoutlen=1
  au InsertLeave * set timeoutlen=1000
augroup END
set timeoutlen=1000 ttimeoutlen=0
" set esckeys " A <esc> is always a <esc> not part a escape sequence(used by older terminals?)

" Blank characters {{{
" debug set with "set list?" ?: means print current value
set list                              " show special chars, such as tab: eol: trail: extends: nbsp:

" chars to show for blank characters
set listchars=tab:\ \ 
" set listchars+=tab:Â·Â»
" set listchars+=eol:Â¬
set listchars+=trail:Â·
set listchars+=nbsp:+

" set showbreak=â†ª\
" char to display when softwrapping
set showbreak="\u21aa"
" }}}

" Search {{{
set incsearch                     " search wile you type
set smartcase                     " Case insensitive search, except when capital letters are used.
set ignorecase                    " ignore case when searching
set hlsearch                      " highlight search result
" }}}

" Visual mode {{{
" move up/down by visual line, will treat wrapped lines as real lines
nnoremap j gj
nnoremap k gk
" }}}

" Spell {{{
function! s:SpSpell()
  setlocal spell!
  if &spell is 1
    echomsg "spell (".&spelllang.")"
  else
    echomsg "nospell"
  endif
  return 0
endfunction
command! SpSpell :call s:SpSpell()
nmap <silent> <f6> :SpSpell<cr>
map zn ]s
map zp [s
map zN [s
" map <leader>sa zg
" map <leader>sq z=
" Drop down menu with spell corrections
nnoremap <leader>z ea<C-X><C-S>

" underline wrongly spelled words
" hi clear SpellBad
" hi SpellBad cterm=underline gui=underline

" set spelllang=en_gb               " Specify the spell checking language.
set nospell                       " Disable spell checking by default.
set dictionary+=/usr/share/dict/words
" Own spell db
set spellfile=~/.vim/spell/en.utf-8.add

source $HOME/.iabrc

" TODO maybe limit to ft=cpp
iab sizoef sizeof
iab doubel double
iab deinfe define
iab memst memset
iab szie_t size_t
iab stati static
iab cosnt const
iab asssert assert
iab treu true
iab pritnf printf
iab szie_t size_t
iab typdef typedef
" }}}

set nowrap                        " do not soft wrap long lines
set backspace=indent,eol,start    " allow backspacing over everything in insert mode
set autoread                      " auto reload after outside changes(tmux sends a event on focus)

" Indentation {{{
" set autoindent                    " use the same indent from current line when starting a new line
" set copyindent                    " use the same character(tabs,spaces...) for indentation as the previous line
" set smartindent                   " support auto indentation when for example the previous line end with { used for (c/c++)
" }}}

" directories {{{
function! s:SetupTmp()
  if has("win32")
    set noswapfile          " no swap
    set noundofile          " no undo file
    set nobackup            " no bak
  else
    if exists('$TMPDIR')
      let l:tmpdir = $TMPDIR
    else
      let l:tmpdir = "/tmp"
    endif
    if has('nvim')
      let l:root = l:tmpdir."/.nvim-".$USER
    else
      let l:root = l:tmpdir."/.vim-".$USER
    endif
    if !isdirectory(l:root)
      call mkdir(l:root, "", 0700)
    endif

    " Undo {{{
    let l:undo = l:root."/undo"
    if !isdirectory(l:undo)
      call mkdir(l:undo, "", 0700)
    endif
    " https://advancedweb.hu/2017/09/12/vim-using-undo-branches
    set undolevels=1000               " Use many levels of undo
    set undofile                      " File Persistent undo
    let &undodir = l:undo."//"
    " }}}

    " swap lock file {{{
    let l:swap = l:root."/swap"
    if !isdirectory(l:swap)
      call mkdir(l:swap, "", 0700)
    endif
    " two slashes means that vim will create unique swap file names per file
    " set directory=l:swap.//
    let &directory=l:swap."//"
    set swapfile
    " }}}

    " Backup {{{
    let l:backup = l:root."/backup"
    if !isdirectory(l:backup)
      call mkdir(l:backup, "", 0700)
    endif
    set nobackup
    " set backup
    " let &dbackupdir=l:backup."//"
    " set writebackup
    " }}}

  endif
endfunction
call s:SetupTmp()

if has('nvim')
  set viminfo+=n~/.cache/nvim/viminfo
else
  set viminfo+=n~/.cache/vim/viminfo
endif
" }}}

" Custom mappings {{{
" Alternative save
" TODO if tabs > 1 do this. other wise remove 'silent!'
nnoremap <leader>w <esc>:silent! wa<CR>
" Alternative quit
nnoremap <silent> <leader>q <esc>:q<CR>

map <silent> <leader>, <esc>:noh<CR>

" resize split
map <silent> <leader>- <esc>:vertical resize -5<CR>
map <silent> <leader>+ <esc>:vertical resize +5<CR>

" Alternative Moving around splits with the leader key
nmap <silent> <leader>h :wincmd h<CR>
nmap <silent> <leader>j :wincmd j<CR>
nmap <silent> <leader>k :wincmd k<CR>
nmap <silent> <leader>l :wincmd l<CR>

" Create vertical pane
nnoremap <leader>s <esc>:vnew<CR>
" Create horizontal pane
" nnoremap <leader>h <esc>:sp<CR>
" Create tab
nnoremap <silent><leader>e <esc>:tabedit<CR>

" new line above and below without entering insert mode
map <silent> <leader>o o<esc>
map <silent> <leader>O O<esc>

" behave similar to D
noremap Y y$
"
" Navigation capital H/L goto extreme Right/Left
noremap H _
noremap L g_

nnoremap <CR> :
vnoremap <CR> :

" Replay macro
noremap Q @q

" }}}

" jumplist {{{
" Store relative line number jumps in the jumplist if they exceed a threshold.
nnoremap <expr> k (v:count > 3 ? "m'" . v:count : '') . 'k'
nnoremap <expr> j (v:count > 3 ? "m'" . v:count : '') . 'j'

nnoremap <expr> + (v:count > 3 ? "m'" . v:count : '') . '+'
nnoremap <expr> - (v:count > 3 ? "m'" . v:count : '') . '-'
" }}}

" Disable Mappings {{{

" Arrow keys
" nnoremap <left> <nop>
" nnoremap <right> <nop>
" nnoremap <up> <nop>
" nnoremap <down> <nop>
"
" inoremap <left> <nop>
" inoremap <right> <nop>
" inoremap <up> <nop>
" inoremap <down> <nop>

" does not work
" nnoremap <s+left> <nop>
" nnoremap <s+right> <nop>
" nnoremap <s+up> <nop>
" nnoremap <s+down> <nop>
"
" inoremap <s+left> <nop>
" inoremap <s+right> <nop>
" inoremap <s+up> <nop>
" inoremap <s+down> <nop>


" disable f1 help
inoremap <F1> <nop>
nnoremap <F1> <nop>
vnoremap <F1> <nop>

" disable man
map <S-k> <Nop>

" Avoid unintentional switches to Ex mode.
nnoremap Q <nop>

" Stop that stupid window from popping up
nmap q: <esc>:q

" remember both line and column with '
nnoremap ' `
nnoremap ` '

"
map + <nop>
map - <nop>

" Keep visual selection during indenting
xnoremap < <gv
xnoremap > >gv|

" }}}

" hexedit {{{
" from :h hex-editing
" xxd is a utility to convert to/from hex - used when opening and closing the
" bin files. when opening a bin file vim will open it for hex editing
augroup BinaryHexEdit
  au!
  au BufReadPre   *.bin,*.img,*.wav,*.pcm,*.raw let &bin=1
  au BufReadPost  *.bin,*.img,*.wav,*.pcm,*.raw if &bin | %!xxd
  au BufReadPost  *.bin,*.img,*.wav,*.pcm,*.raw set ft=xxd | endif
  au BufWritePre  *.bin,*.img,*.wav,*.pcm,*.raw if &bin | %!xxd -r
  au BufWritePre  *.bin,*.img,*.wav,*.pcm,*.raw endif
  au BufWritePost *.bin,*.img,*.wav,*.pcm,*.raw if &bin | %!xxd
  au BufWritePost *.bin,*.img,*.wav,*.pcm,*.raw set nomod | endif
augroup END
" }}}

" Smooth Scrolling {{{
" this leaves the cursor on the same line as apposed to before where it moves
" the cursor.
map <C-U> <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>
map <C-D> <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>
" }}}
"
" modeline {{{
set modelines=1   " turn on vim settings that will be read from the last line
" example:
" vim:foldmethod=marker:foldlevel=0
" python: (remember space after #)
" # vim: tabstop=2 expandtab shiftwidth=2 softtabstop=2
" }}}

" {{{
" force open open file
map <leader>gf :e <cfile><cr>
" }}}

" toggle file {{{
function! s:SpookyMirrorFor(file, match, dest) abort
  " echo "'".a:file."'".a:match."'"
  " echo a:match
  let lres = matchlist(a:file, a:match)
  let res = matchstr(a:file, a:match)
  " echo res
  if !empty(res)
    for cur in a:dest
      let i=1
      while i < len(lres)
        " echo "substitute(".cur.", \\".i.", ".get(lres, i).", \"\")"
        let cur = substitute(cur,'\\'.i , get(lres, i), "g")
        let i += 1
      endwhile
      " echo cur
      if filereadable(cur)
        return cur
      endif
    endfor
  endif

  return ""
endfunction

function! s:SpookyGetMirror(file) abort
  " let fname='\w\+'
  let fname='[a-zA-Z0-9_-]\+'
  " echo a:file

  " if s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.vim$', ['\1/\2.cpp'])
  "   return 0
  " endif

  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/lib\/\('.fname.'\)\.c$', ['\1/include/linux/\2.h'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/kernel\/\('.fname.'\)\.c$', ['\1/include/linux/\2.h'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/linux\/\('.fname.'\)\.h$', ['\1/kernel/\2.c', '\1/lib/\2.c'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " /src/fname.[c, cc, cpp] -> /[include, inc, '']/fname.[h, hh, hpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/src\/\('.fname.'\)\.c$', ['\1/include/\2.h', '\1/inc/\2.h', '\2.h'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/src\/\('.fname.'\)\.cc$', ['\1/include/\2.h', '\1/inc/\2.h', '\2.h', '\1/include/\2.hh', '\1/inc/\2.hh', '\2.hh', '\1/include/\2.hpp', '\1/inc/\2.hpp', '\2.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/src\/\('.fname.'\)\.cpp$', ['\1/include/\2.h', '\1/include/\2.hpp', '\1/include/\2.hh', '\1/inc/\2.h', '\1/inc/\2.hpp', '\1/inc/\2.hh'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " /source/fname.[c, cc, cpp] -> /[include, inc, '']/fname.[h, hh, hpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/source\/\('.fname.'\)\.c$', ['\1/include/\2.h', '\1/inc/\2.h', '\2.h'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/source\/\('.fname.'\)\.cc$', ['\1/include/\2.h', '\1/inc/\2.h', '\2.h', '\1/include/\2.hh', '\1/inc/\2.hh', '\2.hh', '\1/include/\2.hpp', '\1/inc/\2.hpp', '\2.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/source\/\('.fname.'\)\.cpp$', ['\1/include/\2.h', '\1/include/\2.hpp', '\1/include/\2.hh', '\1/inc/\2.h', '\1/inc/\2.hpp', '\1/inc/\2.hh'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " /include/fname.[h, hh, hpp] -> [src, source]/fname.[c, cc, cpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\('.fname.'\)\.h$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\('.fname.'\)\.hh$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\('.fname.'\)\.hpp$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " /inc/fname.[h, hh, hpp] -> [src, source, '']/fname.[c, cc, cpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\('.fname.'\)\.h$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\('.fname.'\)\.hh$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\('.fname.'\)\.hpp$', ['\1/src/\2.cpp', '\1/src/\2.c', '\1/src/\2.cc', '\1/source/\2.cpp', '\1/source/\2.c', '\1/source/\2.cc', '\1/\2.c', '\1/\2.cc', '\1/\2.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " fname.[cpp,cc,c] -> [include, inc, '']/fname.[h,hpp,hh]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.cpp$', ['\1/\2.h', '\1/\2.hpp', '\1/\2.hh', '\1/include/\2.h', '\1/include/\2.hpp', '\1/include/\2.hh', '\1/inc/\2.h', '\1/inc/\2.hpp', '\1/inc/\2.hh'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.cc$', ['\1/\2.h', '\1/\2.hpp', '\1/\2.hh', '\1/include/\2.h', '\1/include/\2.hpp', '\1/include/\2.hh', '\1/inc/\2.h', '\1/inc/\2.hpp', '\1/inc/\2.hh'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.c$', ['\1/\2.h', '\1/include/\2.h', '\1/inc/\2.h'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  " fname.[h,hpp,hh] -> fname.[cpp,c,cc]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.h$', ['\1/\2.cpp', '\1/\2.c', '\1/\2.cc'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.hpp$', ['\1/\2.cpp', '\1/\2.cc'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\('.fname.'\)\.hh$', ['\1/\2.cpp', '\1/\2.cc'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

" /proj/src/fname.[c, cc, cpp] -> /proj/[include, inc]/proj/fname.[h, hh, hpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/src\/\('.fname.'\)\.c$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/src\/\('.fname.'\)\.cc$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/src\/\('.fname.'\)\.cpp$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

" /proj/source/fname.[c,cc,cpp] -> /proj/[include, inc]/proj/fname.[h, hh, hpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/source\/\('.fname.'\)\.c$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/source\/\('.fname.'\)\.cc$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/\(.*\)\/source\/\('.fname.'\)\.cpp$', ['\1/\2/include/\2/\3.h', '\1/\2/inc/\2/\3.h', '\1/\2/include/\2/\3.hh', '\1/\2/inc/\2/\3.hh', '\1/\2/include/\2/\3.hpp', '\1/\2/inc/\2/\3.hpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

"  /proj/include/proj/fname.[h, hh, hpp] -> /proj/[source, src]/fname.[c,cc,cpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\(.*\)\/\('.fname.'\)\.h$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\(.*\)\/\('.fname.'\)\.hh$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/include\/\(.*\)\/\('.fname.'\)\.hpp$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

"  /proj/inc/proj/fname.[h, hh, hpp] -> /proj/[source, src]/fname.[c,cc,cpp]
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\(.*\)\/\('.fname.'\)\.h$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\(.*\)\/\('.fname.'\)\.hh$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif
  let l:mirror = s:SpookyMirrorFor(a:file, '^\(.*\)\/inc\/\(.*\)\/\('.fname.'\)\.hpp$', ['\1/src/\3.c', '\1/src/\3.cc', '\1/src/\3.cpp', '\1/source/\3.c', '\1/source/\3.cc', '\1/source/\3.cpp'])
  if strlen(l:mirror) > 0
    return l:mirror
  endif

  return ""
endfunction

function! s:SpFindGit(path) abort
  let l:parent = a:path

  while 1
    let l:path = l:parent . '/.git'
    if isdirectory(l:path) || filereadable(l:path)
      return l:parent
    endif
    let l:next = fnamemodify(l:parent, ':h')
    if l:next == l:parent
      return ''
    endif
    let l:parent = l:next
  endwhile
endfunction

function! s:SpFindFile(root, needles, ignores) abort
  " find . -type f \( -name "xxx.h" -o -name "xxx.hh" \)
  let l:first = 1
  if len(a:needles) == 0
    return []
  endif

  if !executable('find')
    return []
  endif

  let l:cmd = "find ".a:root." -type f \\("
  for l:needle in a:needles
    if l:first == 0
      let l:cmd .= " -o " " or
    endif
    let l:cmd .= " -name '".l:needle."'"
    let l:first = 0
  endfor
  let l:cmd .= " \\)"
  for l:ignore in a:ignores
    let l:cmd .= " -not -path '*/".l:ignore."/*'"
  endfor
  " echomsg l:cmd
  let l:result = systemlist(l:cmd)
  " echomsg v:shell_error
  " echomsg l:result
  if v:shell_error == 0
    return l:result
  endif

  return []
endfunction


function s:FuncPreview()
  " https://vim.fandom.com/wiki/Quick_reference_of_current_function
  let l:opening = search("^\\S.*)\\s*\\\(\\n\\\)\\={","bn")
  let l:closing = search("^}","bn")
  if l:opening > l:closing
    return '    '.getline(l:opening)
  else
    return ""
  endif
endfunction

function! s:SpookyLimitMsgLength(msg, strip_prefix) abort
  let l:win_width = winwidth(0)-30
  let l:limit = l:win_width < 0 ? 0 : l:win_width
  let l:msg_len = strlen(a:msg)
  if l:msg_len > l:limit
    if a:strip_prefix == 1
      let l:start = l:msg_len-l:limit
      return a:msg[l:start:]
    else
      return a:msg[:l:limit]
    endif
  endif
  return a:msg
endfunction

let s:spoooooky = 0
function! s:SpookyPrintCurrentFile() abort
  let l:strip_prefix = 1
  " redraw
  " escape: Escape the characters in {chars} that occur in {string} with a
  " example: :echo escape('c:\program files\vim', ' \')
  " results in: 'c:\\program\ files\\vim'
  let l:self = expand("%:p")
  let l:parent = expand('%:p:h') " escape()
  let l:git = s:SpFindGit(parent)
  if l:git !=# ''
    let l:self = l:self[len(l:git)+1:len(l:self)]
  endif

  if &ft == "c"
    let l:win_width = winwidth(0)-30
    let l:limit = l:win_width < 0 ? 0 : l:win_width
    if strlen(l:self) < l:limit
      let l:strip_prefix = 0
      let l:self = l:self . s:FuncPreview()
    endif
  endif

  " HACK: fix when opening multiple files to avoid spamming
  " tabpagenr('$'): number of tags?
  if s:spoooooky > tabpagenr('$')
    echomsg s:SpookyLimitMsgLength(l:self, l:strip_prefix)
  endif
  let s:spoooooky = s:spoooooky+1
  " redraw
" echo fnameescape(fnamemodify(finddir('.git',escape(expand('%:p:h'), ' ') . ';'), ':h'))

endfunction

function! s:SpookyToggleFile(fpath, fname, fext) abort
  if !exists("g:sp_toggle_file")
    let g:sp_toggle_file = {}
  endif
  if !exists("g:sp_cached_mirror")
    " cache so that we are not required to repeatedly have to re:find mirror
    let g:sp_cached_mirror = {}
  endif

  let l:mirror = s:SpookyGetMirror(a:fpath)
  if strlen(l:mirror) == 0
    " fallback: we use Linux "find" util to find mirror
    if has_key(g:sp_cached_mirror, a:fpath)
      let l:mirror = g:sp_cached_mirror[a:fpath]
    else
      let l:git_root = s:SpFindGit(a:fpath)
      if strlen(l:git_root) > 0
        let l:ignores =  ['stub','testing','checktest','checktests','tests','test','test-support','testdata','examples','oe-logs','oe-workdir','.ccls-cache','node_modules','tmp','target','build']
        let l:candidates = []
        if a:fext == "c"
          let l:candidates = s:SpFindFile(l:git_root, [a:fname.'.h'], l:ignores)
        elseif a:fext == "cc" || a:fext == "cpp"
          let l:candidates = s:SpFindFile(l:git_root, [a:fname.'.h', a:fname.'.hh', a:fname.'.hpp'], l:ignores)
        elseif a:fext == "hh" || a:fext == "hpp" || a:fext == "h"
          let l:candidates = s:SpFindFile(l:git_root, [a:fname.'.c', a:fname.'.cc', a:fname.'.cpp'], l:ignores)
        endif
        if len(l:candidates) > 0
          let l:mirror = l:candidates[0] " just get the first result
          " cache mirrors:
          let g:sp_cached_mirror[a:fpath] = l:mirror
          let g:sp_cached_mirror[l:mirror] = a:fpath
        endif
      endif
    endif
  endif

  if strlen(l:mirror) > 0
    let g:sp_toggle_file[a:fpath] = winsaveview()
    execute "silent edit ".l:mirror
    if has_key(g:sp_toggle_file, l:mirror)
      call winrestview(g:sp_toggle_file[l:mirror])
    endif
    call s:SpookyPrintCurrentFile()
  endif
endfunction

" autocmd FileType c,cpp
command! SpookyToggleFile :call s:SpookyToggleFile(expand('%:p'), expand('%:t:r'), expand('%:e'))
augroup AugroupToggleFIle
  autocmd!
  autocmd FileType c,cpp nnoremap <buffer> <silent> <F2> :SpookyToggleFile<CR>
augroup END
" }}}

" {{{
function! s:SpookyHeaderType(file) abort
  let l:mirror = s:SpookyGetMirror(a:file)
  if strlen(l:mirror) > 0
    if l:mirror =~ '\.cpp$' || l:mirror =~ '\.cc$'
      set ft=cpp
      return 1
    endif
  endif

  set ft=c
  return 1
endfunction

function! s:SpookySetSpaceIdent() abort
  setlocal listchars+=tab:Â·Â»
  setlocal expandtab       " <tab> is converted to spaces
  setlocal tabstop=2       " Number of spaces that a <Tab> in the file counts for
  setlocal shiftwidth=2    " number of spaces to use for autoindenting
endfunction

function! s:SpookyIndentDetect() abort
" 'vim-plug', '', 'gitcommit', 'tagbar'
  if &buftype ==# 'help'
    return
  endif
  " echomsg "spooky: ".expand('%')

  let heuristics = {'spaces': 1, 'tabs': 0}
  let lines = getline(1, 1024)
  " echomsg "lines: ".len(lines)."|".get(lines, 0, "NONE")."|".len(get(lines, 0, "NONE"))

  for line in lines
    " echomsg line
    if len(line) == 0
      continue
    endif

    " line only containing spaces
    if line =~# '^ *$'
      continue
    endif
    " line only containing tabs
    if line =~# '^\t*$'
      continue
    endif

    " c style multiline comment
    " /*
    " _*/
    if line =~# '^ \*'
      continue
    endif


    if line =~# '^\t'
      let heuristics.tabs += 1
    elseif line =~# '^ '
      let heuristics.spaces += 1
    endif

  endfor

  " set noexpandtab
  " set expandtab                     " <tab> is converted to spaces
  " set shiftwidth=2                  " number of spaces to use for autoindenting
  set smarttab                        " insert tabs on the start of a line according
                                      " to shiftwidth, not tabstop
  " TODO rust indent with two tabs
  " echo "tabs:".heuristics.tabs." spaces:".heuristics.spaces
  if heuristics.tabs > heuristics.spaces
    " echomsg "hard! tabs:".heuristics.tabs." spaces:".heuristics.spaces
    setlocal noexpandtab
    setlocal tabstop=2
    setlocal shiftwidth=2
  else " if heuristics.spaces > heuristics.tabs
    " echomsg "spaces! tabs:".heuristics.tabs." spaces:".heuristics.spaces
    call s:SpookySetSpaceIdent()
  endif
endfunction

" call s:SpookySetSpaceIdent()
let indent_blacklist = ['python']
augroup AutogroupIndentDetect
  autocmd!
  autocmd BufReadPost,FileReadPost * if index(indent_blacklist, &ft) < 0 | call s:SpookyIndentDetect() | endif
  " autocmd FileType call s:SpookyIndentDetect()
augroup END

augroup AutogroupFileSpecific
  autocmd!

  " manually set filetype based on ext
  autocmd BufNewFile,BufFilePre,BufRead *.md set ft=markdown
  autocmd BufNewFile,BufFilePre,BufRead *.vertexshader set ft=glsl
  autocmd BufNewFile,BufFilePre,BufRead *.fragmentshader set ft=glsl
  " https://github.com/Shirk/vim-gas
  autocmd BufNewFile,BufRead *.nasm set ft=nasm
  autocmd BufNewFile,BufRead *.fpp set ft=sh

  " type specific settings
  autocmd FileType markdown setlocal ts=2 sw=2 expandtab
  autocmd FileType markdown,text,mail,tex setlocal textwidth=80
  autocmd FileType gitcommit setlocal textwidth=72
  autocmd FileType gitcommit,markdown,text,mail,tex setlocal colorcolumn=-1   " display bar at textwidth
  autocmd FileType gitcommit,markdown,text,mail setlocal complete+=kspell
" enable spelling for these types
  autocmd FileType gitcommit,mail setlocal spell

  " set file type for files without extension like <atomic>
  autocmd BufRead,BufNewFile /usr/include/c++/* set ft=cpp
  autocmd BufRead,BufNewFile /usr/lib/gcc/* set ft=cpp
  autocmd BufRead,BufNewFile Kbuild.include set ft=make

  autocmd BufRead,BufNewFile *.json.fpp set ft=json

  "
  autocmd BufNewFile,BufFilePre,BufRead *.h call s:SpookyHeaderType(expand('%:p'))
augroup END
" }}}

"nnoremap
" map <silent> gt :tabnext <bar> redraw <bar> echo @%<cr>
" nnoremap <expr> gt :tabnext v:count <bar> redraw <bar> echo @%<cr>
" function! s:SpookyTabPriv() abort
"   tabprevious
"   call s:SpookyPrintCurrentFile()
" endfunction
" command! SpookyTabPriv :call s:SpookyTabPriv()
"
" nmap <silent> gT :SpookyTabPriv<cr>
" " map <silent> gT :tabprevious <bar> redraw <bar> echo @%<cr>
"
" function! SpookyTabNext(cnt) abort
"   " echomsg " tabpagenr():".tabpagenr()." a:cnt:".a:cnt
"   if a:cnt > 0
"     " echomsg " tabpagenr():".tabpagenr()." a:cnt:".a:cnt
"     if tabpagenr() == a:cnt
"       return
"     endif
"     execute "tabnext ".a:cnt
"   else
"     tabnext
"   endif
"   call s:SpookyPrintCurrentFile()
" endfunction
"
" nmap <silent> gt :<C-U>call SpookyTabNext(v:count)<cr>
augroup AutogroupPrintCurrentTab
    autocmd!
    autocmd TabEnter * call s:SpookyPrintCurrentFile()
    " autocmd BufEnter * call s:SpookyPrintCurrentFile()
augroup END

" set laststatus=2
" set statusline+=%F
"
" nnoremap <expr> - (v:count > 3 ? "m'" . v:count : '') . '-'

function! s:SpMathFormat() range
  function! s:Xx(str)
    let l:result = ""
    let l:state = 0
    let l:del = { 'cnt': 0, 'mem': '', 'inzert':'', 'cmp':'' }
    let l:sub_sup = { 'cnt': 0 } " to support alone: _ ^
    let l:open_brace_cnt=0 " pairing up () or returning to state:0

" http://shapecatcher.com/unicode/block/Mathematical_Operators
" http://shapecatcher.com/unicode/block/Supplemental_Mathematical_Operators
" https://en.wikipedia.org/wiki/Rotated_letter
    let l:complex = { '(xor)': 'âŠ•', '(subset)': 'âŠ‚',
                    \ '(qed)': 'âˆ', '(element)': 'âˆŠ' , '(not)': 'Â¬', 
                    \ '(_alpha)': 'Î±', '(alpha)': 'Î‘',
                    \ '(beta)': 'Î’', '(_beta)': 'Î²', 
                    \ '(_gamma)': 'ğ›¾', '(gamma)': 'Î“',
                    \ '(delta)': 'Î”', '(_delta)': 'Î´',
                    \ '(_epsilon)': 'Îµ', '(epsilon)': 'Î•',
                    \ '(digamma)': 'Ïœ', '(_digamma)': 'Ï',
                    \ '(zeta)': 'Î–', '(_zeta)': 'Î¶',
                    \ '(eta)': 'Î—', '(_eta)': 'Î·',
                    \ '(elipsis)': 'â‹®', '(ellipsis)': 'â‹®', '(...)': 'â‹®',
                    \ '(theta)': 'Î˜', '(_theta)': 'Î¸', '(_theta2)': 'Ï‘',
                    \ '(iota)': 'Î™', '(_iota)': 'Î¹',
                    \ '(kappa)': 'Îš', '(_kappa)': 'Îº',
                    \ '(_lambda)': 'Î»', '(lambda)': 'Î›',
                    \ '(mu)':'Îœ', '(_mu)':'Î¼',
                    \ '(nu)':'Î', '(_nu)':'Î½',
                    \ '(xi)':'Î', '(_xi)':'Î¾',
                    \ '(omicron)':'ÎŸ', '(_omicron)':'Î¿',
                    \ '(_pi)': 'Ï€', '(pi)': 'Î ',
                    \ '(_rho)': 'Ï', '(rho)': 'Î¡',
                    \ '(integral)': 'âˆ«', '(integrate)': 'âˆ«',
                    \ '(mul)': 'âˆ', '(product)': 'âˆ',
                    \ '(sigma)': 'âˆ‘', '(_sigma)': 'Ïƒ','(_sigma2)': 'Ï‚',
                    \ '(_tau)': 'Ï„', '(tau)': 'Î¤',
                    \ '(_upsilon)': 'Ï…', '(upsilon)': 'Ï’',
                    \ '(_phi)': 'Ï†', '(_phi2)': 'Ï•', '(phi)': 'Î¦',
                    \ '(_chi)': 'Ï‡','(chi)': 'Î§',
                    \ '(psi)': 'Î¨', '(_psi)': 'Ïˆ',
                    \ '(omega)': 'Î©', '(_omega)': 'Ï‰',
                    \ '(micro)': 'Âµ', '(infinity)': 'âˆ', '(inf)': 'âˆ', '(f)': 'Æ’', '(frequency)': 'Æ’',
                    \ '(sqrt)': 'âˆš', '(cbrt)': 'âˆ›', '(qdrt)': 'âˆœ',
                    \ '(proportional)': 'âˆ',
                    \ '(almost)': 'â‰ˆ', '(aprox)': 'â‰ˆ', '(approx)': 'â‰ˆ', 
                    \ '(member)': 'âˆˆ', '(nmember)': 'âˆ‰', '(angle)': 'âˆ ', 
                    \ '(prime)': 'â„™', '(natural)': 'â„•', '(integer)': 'â„¤', '(rational)': 'â„š', '(real)': 'â„',
                    \ '(forall)': 'âˆ€', '(z)':'Æ¶', '(Z)':'Æµ', '=>':'â‡’', '==>': 'âŸ¹',
                    \ '(1/4)': 'Â¼', '(1/2)': 'Â½', '(3/4)': 'Â¾', '(1/7)': 'â…', '(1/9)': 'â…‘', '(1/3)': 'â…“',
                    \ '(2/3)': 'â…”', '(1/10)': 'â…’', '(1/5)': 'â…•', '(2/5)': 'â…–', '(3/5)':'â…—', '(4/5)': 'â…˜',
                    \ '(1/6)': 'â…™', '(5/6)':'â…š', '(1/8)': 'â…›', '(3/8)':'â…œ', '(5/8)': 'â…', '(7/8)': 'â…',
                    \ '(1/)': 'â…Ÿ', '(0/3)': 'â†‰', '(congruent)': 'â‰¡',
                    \ '(<--)': 'âŸµ', '(-->)': 'âŸ¶', '(<-->)': 'âŸ·', '(<==)': 'âŸ¸', '(==>)': 'âŸ¹', '(<==>)': 'âŸº',
                    \ '(!<)': 'â‰®',
                    \ '(^\)': 'â†–', '(/^)': 'â†—', '(\V)': 'â†˜', '(V/)': 'â†™', '(\v)': 'â†˜', '(v/)': 'â†™', '(V\)': 'â†˜', '(/V)': 'â†™', '(v\)': 'â†˜', '(/v)': 'â†™',
                    \ '(<=)': 'â‡', '(^=)': 'â‡‘', '(=>)': 'â‡’', '(V=)': 'â‡“', '(<=>)': 'â‡”', '(V=^)': 'â‡•', '(^=V)': 'â‡•',
                    \ '(<-)': 'â†', '(|^)': 'â†‘', '(^|)': 'â†‘', '(^)': 'â†‘', '(->)': 'â†’', '(V)': 'â†“', '(|V)': 'â†“', '(V|)': 'â†“', '(<>)': 'â†”', '(^V)': 'â†•', '(V^)': 'â†•', '(^|V)': 'â†•', '(V|^)': 'â†•',
                    \ '(<->)': 'â†”',
                    \ '(union)': 'âˆª', '(intersect)': 'âˆ©', '(superset)': 'âŠƒ', '(empty)': 'âˆ…',
                    \ '(F)': 'ğ“•',
                    \ '(/A/)': 'ğ“',
                    \ '(/B/)': 'ğ“‘',
                    \ '(/C/)': 'ğ“’',
                    \ '(/D/)': 'ğ““',
                    \ '(/E/)': 'ğ“”',
                    \ '(/F/)': 'ğ“•',
                    \ '(/G/)': 'ğ“–',
                    \ '(/H/)': 'ğ“—',
                    \ '(/I/)': 'ğ“˜',
                    \ '(/J/)': 'ğ“™',
                    \ '(/K/)': 'ğ“š',
                    \ '(/L/)': 'ğ“›',
                    \ '(/M/)': 'ğ“œ',
                    \ '(/N/)': 'ğ“',
                    \ '(/O/)': 'ğ“',
                    \ '(/P/)': 'ğ“Ÿ',
                    \ '(/Q/)': 'ğ“ ',
                    \ '(/R/)': 'ğ“¡',
                    \ '(/S/)': 'ğ“¢',
                    \ '(/T/)': 'ğ“£',
                    \ '(/U/)': 'ğ“¤',
                    \ '(/V/)': 'ğ“¥',
                    \ '(/W/)': 'ğ“¦',
                    \ '(/X/)': 'ğ“§',
                    \ '(/Y/)': 'ğ“¨',
                    \ '(/Z/)': 'ğ“©',
                    \ '(/a/)': 'ğ“ª',
                    \ '(/b/)': 'ğ“«',
                    \ '(/c/)': 'ğ“¬',
                    \ '(/d/)': 'ğ“­',
                    \ '(/e/)': 'ğ“®',
                    \ '(/f/)': 'ğ“¯',
                    \ '(/g/)': 'ğ“°',
                    \ '(/h/)': 'ğ“±',
                    \ '(/i/)': 'ğ“²',
                    \ '(/j/)': 'ğ“³',
                    \ '(/k/)': 'ğ“´',
                    \ '(/l/)': 'ğ“µ',
                    \ '(/m/)': 'ğ“¶',
                    \ '(/n/)': 'ğ“·',
                    \ '(/o/)': 'ğ“¸',
                    \ '(/p/)': 'ğ“¹',
                    \ '(/q/)': 'ğ“º',
                    \ '(/r/)': 'ğ“»',
                    \ '(/s/)': 'ğ“¼',
                    \ '(/t/)': 'ğ“½',
                    \ '(/u/)': 'ğ“¾',
                    \ '(/v/)': 'ğ“¿',
                    \ '(AA)': 'ğ”¸',
                    \ '(BB)': 'ğ”¹',
                    \ '(CC)': 'â„‚',
                    \ '(DD)': 'ğ”»',
                    \ '(EE)': 'ğ”¼',
                    \ '(FF)': 'ğ”½',
                    \ '(GG)': 'ğ”¾',
                    \ '(HH)': 'â„',
                    \ '(II)': 'ğ•€',
                    \ '(JJ)': 'ğ•',
                    \ '(KK)': 'ğ•‚',
                    \ '(LL)': 'ğ•ƒ',
                    \ '(MM)': 'ğ•„',
                    \ '(NN)': 'â„•',
                    \ '(OO)': 'ğ•†',
                    \ '(PP)': 'â„™',
                    \ '(QQ)': 'â„š',
                    \ '(RR)': 'â„',
                    \ '(SS)': 'ğ•Š',
                    \ '(TT)': 'ğ•‹',
                    \ '(UU)': 'ğ•Œ',
                    \ '(VV)': 'ğ•',
                    \ '(WW)': 'ğ•',
                    \ '(XX)': 'ğ•',
                    \ '(YY)': 'ğ•',
                    \ '(ZZ)': 'â„¤',
                    \ '(aa)': 'ğ•’',
                    \ '(bb)': 'ğ•“',
                    \ '(cc)': 'ğ•”',
                    \ '(dd)': 'ğ••',
                    \ '(ee)': 'ğ•–',
                    \ '(ff)': 'ğ•—',
                    \ '(gg)': 'ğ•˜',
                    \ '(hh)': 'ğ•™',
                    \ '(ii)': 'ğ•š',
                    \ '(jj)': 'ğ•›',
                    \ '(kk)': 'ğ•œ',
                    \ '(ll)': 'ğ•',
                    \ '(mm)': 'ğ•',
                    \ '(nn)': 'ğ•Ÿ',
                    \ '(oo)': 'ğ• ',
                    \ '(pp)': 'ğ•¡',
                    \ '(qq)': 'ğ•¢',
                    \ '(rr)': 'ğ•£',
                    \ '(ss)': 'ğ•¤',
                    \ '(tt)': 'ğ•¥',
                    \ '(uu)': 'ğ•¦',
                    \ '(vv)': 'ğ•§',
                    \ '(ww)': 'ğ•¨',
                    \ '(xx)': 'ğ•©',
                    \ '(yy)': 'ğ•ª',
                    \ '(zz)': 'ğ•«',
                    \ '(tick)': 'ğŸ—¸', '(untick)': 'âœ—', 
                    \ '(check)': 'ğŸ—¸', '(uncheck)': 'âœ—', 
                    \ '(AC)': 'â¦', '(degree)': 'Â°', '(degrees)': 'Â°', '(cringle)': 'â—¦',
                    \ '(ceil)':'âŒˆâŒ‰', '(floor)': 'âŒŠâŒ‹', '(imaginary)': 'â„‘', '(ground)': 'âš',
                    \ '(Abar)': "A\u0305", '(abar)': "a\u0305",
                    \ '(bbar)': "b\u0305", '(Bbar)': "B\u0305",
                    \ '(cbar)': "c\u0305", '(Cbar)': "C\u0305",
                    \ '(dbar)': "d\u0305", '(Dbar)': "D\u0305",
                    \ '(Ebar)': 'Ä’', '(ebar)': 'Ä“',
                    \ '(fbar)': "f\u0305", '(Fbar)': "F\u0305",
                    \ '(Gbar)': 'á¸ ', '(gbar)': 'á¸¡', 
                    \ '(hbar)': "h\u0305", '(Hbar)': "H\u0305",
                    \ '(Ibar)': 'Äª', '(ibar)': 'Ä«',
                    \ '(jbar)': "j\u0305", '(Jbar)': "J\u0305",
                    \ '(kbar)': "k\u0305", '(Kbar)': "K\u0305",
                    \ '(lbar)': "l\u0305", '(Lbar)': "L\u0305",
                    \ '(mbar)': "m\u0305", '(Mbar)': "M\u0305",
                    \ '(nbar)': "n\u0305", '(Nbar)': "N\u0305",
                    \ '(Obar)': 'ÅŒ', '(obar)': 'Å',
                    \ '(pbar)': "p\u0305", '(Pbar)': "P\u0305",
                    \ '(qbar)': "q\u0305", '(Qbar)': "Q\u0305",
                    \ '(rbar)': 'rÌ„', '(Rbar)': 'RÌ„',
                    \ '(sbar)': "s\u0305", '(Sbar)': "S\u0305",
                    \ '(tbar)': "t\u0305", '(Tbar)': "T\u0305",
                    \ '(Ybar)':'È²', '(ybar)':'È³',
                    \ '(Ubar)': 'Åª', '(ubar)': 'Å«',
                    \ '(vbar)': "v\u0305", '(Vbar)': "V\u0305",
                    \ '(wbar)': "w\u0305", '(Wbar)': "W\u0305",
                    \ '(xbar)': 'xÌ„', '(Xbar)': 'XÌ„',
                    \ '(zbar)': 'zÌ„', '(Zbar)': 'ZÌ„',
                    \ '(<<<)': 'â‹˜', '(>>>)': 'â‹™', '(<<)': 'â‰ª', '(>>)': 'â‰«', 
                    \ '(ahat)': 'Ã¢','(Ahat)': 'Ã‚',
                    \ '(bhat)': "b\u0302", '(Bhat)': "B\u0302",
                    \ '(chat)': 'Ä‰','(Chat)': 'Äˆ',
                    \ '(dhat)': "d\u0302", '(Dhat)': "D\u0302",
                    \ '(ehat)': 'Ãª','(Ehat)': 'ÃŠ',
                    \ '(fhat)': "f\u0302", '(Fhat)': "F\u0302",
                    \ '(ghat)': 'Ä','(Ghat)': 'Äœ',
                    \ '(hhat)': 'Ä¥','(Hhat)': 'Ä¤',
                    \ '(ihat)': 'Ã®','(Ihat)': 'Ã',
                    \ '(jhat)': 'Äµ','(Jhat)': 'Ä´',
                    \ '(khat)': 'kÌ‚', '(Khat)': 'KÌ‚',
                    \ '(lhat)': "l\u0302", '(Lhat)': "L\u0302",
                    \ '(mhat)': "m\u0302", '(Mhat)': "M\u0302",
                    \ '(nhat)': "n\u0302", '(Nhat)': "N\u0302",
                    \ '(ohat)': 'Ã´','(Ohat)': 'Ã”',
                    \ '(phat)': 'pÌ‚','(Phat)': 'PÌ‚',
                    \ '(qhat)': "q\u0302", '(Qhat)': "Q\u0302",
                    \ '(rhat)': "r\u0302", '(Rhat)': "R\u0302",
                    \ '(shat)': 'Å','(Shat)': 'Åœ',
                    \ '(that)': "t\u0302", '(That)': "T\u0302",
                    \ '(yhat)': 'Å·', '(Yhat)': 'Å¶',
                    \ '(uhat)': 'Ã»', '(Uhat)': 'Ã›',
                    \ '(vhat)': "v\u0302", '(Vhat)': "V\u0302",
                    \ '(what)': "w\u0302", '(What)': "W\u0302",
                    \ '(xhat)': "x\u0302", '(Xhat)': "X\u0302",
                    \ '(zhat)': 'áº‘', '(Zhat)': 'áº',
                    \ '(deriviate)': 'âˆ‚', '(derivative)': 'âˆ‚', '(derivate)': 'âˆ‚', '(direvate)': 'âˆ‚', '(del)': 'âˆ‚',
                    \ '(lcursive)': 'â„“',
                    \ '(nabla)': 'âˆ‡', '(n)': 'Î·', '(times)': 'Ã—',
                    \ '(antenna)': 'ğŒ™',
                    \ '(*)': 'Ã—', '(x)': 'Ã—',
                    \ '(atilde)': "a\u0303", '(Atilde)': "A\u0303",
                    \ '(btilde)': "b\u0303", '(Btilde)': "B\u0303",
                    \ '(ctilde)': "c\u0303", '(Ctilde)': "C\u0303",
                    \ '(dtilde)': "d\u0303", '(Dtilde)': "D\u0303",
                    \ '(etilde)': "e\u0303", '(Etilde)': "E\u0303",
                    \ '(ftilde)': "f\u0303", '(Ftilde)': "F\u0303",
                    \ '(gtilde)': "g\u0303", '(Gtilde)': "G\u0303",
                    \ '(htilde)': "h\u0303", '(Htilde)': "H\u0303",
                    \ '(itilde)': "i\u0303", '(Itilde)': "I\u0303",
                    \ '(jtilde)': "j\u0303", '(Jtilde)': "J\u0303",
                    \ '(ktilde)': "k\u0303", '(Ktilde)': "K\u0303",
                    \ '(ltilde)': "l\u0303", '(Ltilde)': "L\u0303",
                    \ '(mtilde)': "m\u0303", '(Mtilde)': "M\u0303",
                    \ '(ntilde)': "n\u0303", '(Ntilde)': "N\u0303",
                    \ '(otilde)': "o\u0303", '(Otilde)': "O\u0303",
                    \ '(ptilde)': "p\u0303", '(Ptilde)': "P\u0303",
                    \ '(qtilde)': "q\u0303", '(Qtilde)': "Q\u0303",
                    \ '(rtilde)': "r\u0303", '(Rtilde)': "R\u0303",
                    \ '(stilde)': "s\u0303", '(Stilde)': "S\u0303",
                    \ '(ttilde)': "t\u0303", '(Ttilde)': "T\u0303",
                    \ '(ytilde)': "y\u0303", '(Ytilde)': "Y\u0303",
                    \ '(utilde)': "u\u0303", '(Utilde)': "U\u0303",
                    \ '(vtilde)': "v\u0303", '(Vtilde)': "V\u0303",
                    \ '(wtilde)': "w\u0303", '(Wtilde)': "W\u0303",
                    \ '(xtilde)': "x\u0303", '(Xtilde)': "X\u0303",
                    \ '(ztilde)': "z\u0303", '(Ztilde)': "Z\u0303",
                    \ '(counter-clockwise)': 'â†º', '(counterclockwise)': 'â†º', '(clockwise)': 'â†»'}
" ÃƒÃ‘Ã•Ä¨Å¨á»¸
" Ã£Ã±ÃµÄ©Å©á»¹
    " TODO http://shapecatcher.com/unicode/block/Number_Forms
    let l:complex_mem = {'index': 0, 'candidates': deepcopy(l:complex), 'memory': ''}

    for l:char in split(a:str, '\zs')
      " á´­ á´¯ á´² á´» á´½ áµ‚ áµ„ áµ† áµŠ áµ‹ áµŒ áµ“ áµš
      "
      " Cyrillic áµ¸
      " other áµ” áµ• áµ™ áµœ
      " á¶› á¶œ á¶ á¶ á¶Ÿ á¶  á¶¡ á¶¢ á¶£ á¶¤ á¶¥ á¶¦ á¶§ á¶¨ á¶© á¶ª á¶« á¶¬ á¶­ á¶® á¶¯ á¶° á¶± á¶² á¶³ á¶´ á¶µ á¶¶ á¶· á¶¸ á¶¹ á¶º á¶» á¶¼ á¶½ á¶¾
      " á á¥ á¦ á¨
      " áª á‘Š á‘‹ á’ƒ á’„ á’¡ á’¢ á’» á’¼ á’½ á’¾ á“ á“‘ á“’ á“ª á“« á”… á”† á”‡ á”ˆ á”‰ á”Š á”‹ á”¥ á”¾ á”¿ á•€ á• á• á•‘ á• á•ª á•» á•¯ á•½ á–… á–• á–– á–Ÿ á–¦ á–® á—® á˜ á™† á™‡ á™¾
      " á£• á£– á£— á£™ á£š á£› á£œ á£ á£ á£Ÿ á£³ á£´ á£µ
      if l:state == 1 " ^ (superscript)
        let l:dict = {  '0': 'â°', '1': 'Â¹', '2': 'Â²', '3': 'Â³', '4': 'â´', '5': 'âµ',
                       \ '6': 'â¶', '7': 'â·', '8': 'â¸', '9': 'â¹', 'i': 'â±', 'a': 'áµƒ',
                       \ 'b': 'áµ‡', 'c': 'á¶œ', 'd': 'áµˆ', 'e': 'áµ‰', 'f': 'á¶ ', 'g': 'áµ',
                       \ 'h': 'Ê°', 'k': 'áµ', 'l': 'Ë¡', 'm': 'áµ', 'n': 'â¿', 'o': 'áµ’',
                       \ 'p': 'áµ–', 'q': 'ğ¥', 'r': 'Ê³', 's': 'Ë¢', 't': 'áµ—', 'u': 'áµ˜', 'v': 'áµ›',
                       \ 'w': 'Ê·', 'x': 'Ë£', 'y': 'Ê¸', 'z': 'á¶»', 'j': 'Ê²',
                       \ '+': 'á©', 'âˆ’': 'â»', '-': 'â»', '(': 'â½', ')': 'â¾', 'A': 'á´¬', 'B': 'á´®', 'C': 'êŸ²',
                       \ 'D': 'á´°', 'E': 'á´±', 'F': 'êŸ³', 'G': 'á´³', 'H': 'á´´', 'I': 'á´µ', 'J': 'á´¶',
                       \ 'K': 'á´·', 'L': 'á´¸', 'M': 'á´¹', 'N': 'á´º', 'O': 'á´¼', 'P': 'á´¾', 'Q': 'êŸ´', 'R': 'á´¿',
                       \ 'T': 'áµ€', 'U': 'áµ', 'V': 'â±½', 'Z': 'á¶»',
                       \ 'Î·': 'áµ‘', '!': 'áµ',
                       \ 'Î²': 'áµ', 'Î˜': 'á¶¿', 'Î¦': 'áµ ', 'Î§': 'áµ¡','Î¸':'á¶¿','ğ›¾': 'áµ', 'Î´': 'áµŸ',
                       \ 'Î“': 'á£˜', 'Î±': 'áµ…',
                       \ 'Ï€': ' â·«', ',': '`', '.':'Î‡', '`': 'ğ„’', 'âˆ':' áª²',
                       \ 'âˆ«': 'â—Œá·¯',
                       \ '$': 'á™š', 'Î›': 'á£”', '<': 'á‘‰', '_': 'á§', '\': 'á ', '/': 'áŸ', 'Ï‰': 'áœ',
                       \ 'Î”': 'á', '=': 'á™¿', 'âˆ©': 'á¢', 'âˆª': 'á¡', 'âŠƒ': 'á£', 'Â°': 'á£', 'âˆ': 'á£³', 'â—¦': 'á¤'
                       \}

        let l:default = 'a'
        let l:super = get(l:dict, l:char, l:default)
        if l:super == l:default
          if l:sub_sup.cnt == 0
            let l:result = l:result.'^'
          endif
          let l:state = 0
          let l:open_brace_cnt = 0
          let l:sub_sup = { 'cnt': 0 }
        else
          if l:char == '('
            let l:open_brace_cnt += 1
          endif
          if l:char == ')'
            if l:open_brace_cnt > 0
              let l:open_brace_cnt -= 1
            else
              let l:state = 0
              let l:open_brace_cnt = 0
              let l:sub_sup = { 'cnt': 0 }
            endif
          endif
        endif

        if l:state == 1 " ^
          let l:sub_sup.cnt += 1
          let l:result = l:result.l:super
        endif
      endif

      if l:state == 2 " _ (subscript)
        let l:dict = { '0': 'â‚€', '1': 'â‚', '2': 'â‚‚', '3': 'â‚ƒ', '4': 'â‚„',
                    \ '5': 'â‚…', '6': 'â‚†', '7': 'â‚‡', '8': 'â‚ˆ', '9': 'â‚‰',
                    \ 'a': 'â‚', 'e': 'â‚‘', 'o': 'â‚’', 'h': 'â‚•', 'k': 'â‚–',
                    \ 'l': 'â‚—', 'm': 'â‚˜', 'p': 'â‚š', 'P':'áµ¨', 's': 'â‚›', 't': 'â‚œ',
                    \ 'n': 'â‚™', 'i': 'áµ¢', 'y': 'áµ§', 'x': 'â‚“', 'j': 'â±¼', 'Ç': 'â‚”', 'r': 'áµ£', 'u': 'áµ¤', 'v': 'áµ¥',
                    \ '+': 'â‚Š', 'âˆ’': 'â‚‹', '-' :'â‚‹', '(': 'â‚', ')': 'â‚', '=': 'â‚Œ',
                    \ ',': ',', "'": 'â€š', '"': 'â€',
                    \ 'ğ›¾': 'áµ§', 'Î¦': 'áµ©', 'Î§': 'áµª', 'Î¡': 'áµ¨',
                    \ 'Ï†': 'áµ©', 'Î²': 'áµ¦', 'Ï‡': 'áµª'
                    \}

        let l:default = 'a'
        let l:sub = get(l:dict, l:char, l:default)
        if l:sub == l:default
          if l:sub_sup.cnt == 0
            let l:result = l:result.'_'
          endif
          let l:state = 0
          let l:sub_sup = { 'cnt': 0 }
        else
          if l:char == '('
            let l:open_brace_cnt += 1
          endif
          if l:char == ')'
            if l:open_brace_cnt > 0
              let l:open_brace_cnt -= 1
            else
              let l:state = 0
              let l:open_brace_cnt = 0
              let l:sub_sup = { 'cnt': 0 }
            endif
          endif

          if l:state == 2 " _
            let l:sub_sup.cnt += 1
            let l:result = l:result.l:sub
          endif
        endif
      endif

      if l:state == 3 " del +-: Â±
        if l:char == l:del.cmp
          let l:del.cnt -= 1
          let l:del.mem .= l:char
          if l:del.cnt == 0
            let l:result = l:result.l:del.inzert
            let l:del = { 'cnt': 0, 'mem': '', 'inzert':'', 'cmp':'' }
            let l:state = 4 " skip
          endif
        else " do not match so add memory
          let l:result = l:result.l:del.mem
          let l:del = { 'cnt': 0, 'mem': '', 'inzert':'', 'cmp':'' }
          let l:state = 0
        endif
      endif

      if l:state == 5 " example: (xor)
        for [l:key, l:value] in items(l:complex_mem.candidates)
          if strlen(l:key) < strlen(l:complex_mem.memory)
            call remove(l:complex_mem.candidates, l:key)
          else
            if l:key[strlen(l:complex_mem.memory)] !=# l:char
              call remove(l:complex_mem.candidates, l:key)
            else
              let l:tmp_key=l:key
              let l:tmp_value=l:value
            endif
          endif
        endfor

        if len(l:complex_mem.candidates) == 0
          let l:result = l:result.l:complex_mem.memory
          let l:state = 0
          let l:complex_mem = {'index': 0, 'candidates': deepcopy(l:complex), 'memory': ''}
        elseif len(l:complex_mem.candidates) == 1 && strlen(l:tmp_key) == strlen(l:complex_mem.memory)+1
          let l:tmp = l:complex_mem.memory.l:char
          if l:tmp_key ==# l:tmp
            let l:result = l:result.l:tmp_value
            let l:state = 4 " skip
          else
            let l:result = l:result.l:complex_mem.memory
            let l:state = 0
          endif
          let l:complex_mem = {'index': 0, 'candidates': deepcopy(l:complex), 'memory': ''}
        else
          let l:complex_mem.memory .= l:char
        endif
      endif

      if l:state == 0
        if l:char == '_'
          let l:state = 2
        elseif l:char == '^'
          let l:state = 1
        elseif l:char == '*'
          " let l:result = l:result.'â‹…'
          let l:result = l:result.'Â·'
        elseif l:char == '.'
          let l:state = 3 " del
          let l:del.cmp = '.'
          let l:del.cnt = 2
          let l:del.inzert = 'â€¦'
          let l:del.mem = l:char
        elseif l:char == '+'
          let l:state = 3 " del
          let l:del.cmp = '-'
          let l:del.cnt = 1
          let l:del.inzert = 'Â±'
          let l:del.mem = l:char
        elseif l:char == '!'
          let l:state = 3 " del
          let l:del.cmp = '='
          let l:del.cnt = 1
          let l:del.inzert = 'â‰ '
          let l:del.mem = l:char
        elseif l:char == '>'
          let l:state = 3 " del
          let l:del.cmp = '='
          let l:del.cnt = 1
          let l:del.inzert = 'â‰¥'
          let l:del.mem = l:char
        elseif l:char == '<'
          let l:state = 3 " del
          let l:del.cmp = '='
          let l:del.cnt = 1
          let l:del.inzert = 'â‰¤'
          let l:del.mem = l:char
        elseif l:char == '('
          let l:state = 5 "
          let l:complex_mem.memory = l:char
        else
          let l:result = l:result.l:char
          " echomsg '-'.l:char
        endif
      endif

      " echomsg '['.l:char.']:'.l:state.'"'.l:result.'"'
      if l:state == 4 " skip"
        let l:state = 0
      endif

    endfor

    if l:state == 1 " ^
      if l:sub_sup.cnt == 0
        let l:result = l:result.'^'
      endif
    endif
    if l:state == 2 "_
      if l:sub_sup.cnt == 0
        let l:result = l:result.'_'
      endif
    endif
    if l:state == 3 " del
      let l:result = l:result.l:del.mem
    endif

    if l:state == 5 " (xor)
      let l:result = l:result.l:complex_mem.memory
    endif

    return l:result
  endfunction

  let [l:line_start, l:col_start] = getpos("'<")[1:2]
  let [l:line_end, l:col_end] = getpos("'>")[1:2]
  let l:lines = range(line_start, line_end)

  for l:lit in l:lines
    let l:str_line = getline(l:lit)
    let l:cs = 0
    let l:ce = strlen(l:str_line)
    let l:whole_line = 1

    if l:lit == l:line_start
      let l:cs = l:col_start-1
      let l:whole_line = 0
    endif
    if l:lit == l:line_end
      let l:ce = l:col_end-1
      let l:whole_line = 0
    endif

    if l:whole_line == 0
      " echo ":".l:ce
      let l:ln = l:str_line[l:cs : l:ce]
      " echo "|".l:ln."|"
    else
      let l:ln = l:str_line
    endif
    let l:enhanced_line = s:Xx(l:ln)
    if l:whole_line == 0
      " echo 0."|".l:str_line[0: l:cs]."|".l:cs
      let l:prefix=""
      if l:cs != 0
        let l:prefix=l:str_line[0: l:cs-1]
      endif

      " echomsg "|".l:prefix."|".l:enhanced_line."|".l:str_line[l:ce+1: -1]."|"
      call setline(l:lit, l:prefix.l:enhanced_line.l:str_line[l:ce+1: -1])
    else
      " echomsg "[".l:enhanced_line."]"
      call setline(l:lit, l:enhanced_line)
    endif

    " echo l:whole_line."|".l:ln
  endfor

  " set cursor at start of selection
  call cursor(l:line_start,l:col_start)

  "                        line
  "                      __|_  __column__
  " whole line start [0, 1464, 1         , 0]
  " while line end   [0, 1466, 2147483647, 0]
  " echo getpos("'<")
  " echo getpos("'>")
  " echo l:line_start. " ".l:line_end
  " echo l:col_start. " ".l:col_end

  " fun! s:replace_in_line(lnum, col_start, col_end, item)
  " let l:curline = getline(a:lnum)
  " let l:newline = l:curline[0: a:col_start] . a:item . l:curline[a:col_end: -1]
  " call setline(a:lnum, l:newline)
  " endfun
  " TODO:
  " (n)     â›nâ
  " ( ) =   âœ âŸ
  " (k)     âkâ 
  " TODO -+-- should not be translated to -Â±-
endfunction
command! -range SpMathFormat <line1>,<line2>call s:SpMathFormat()
xnoremap <leader>m <Esc>:SpMathFormat<CR>

function! s:SpookyToString(kind)
  let l:exe = 'sp_struct_to_string'
  if executable(l:exe)
    " let l:real_fname = expand('%:t')
    let l:tmpfile = tempname()
    let l:real_file = expand('%:p')
    if len(l:real_file) > 0
      let l:tmpfile .= substitute(l:real_file,'/','-','g')
    else
      if &ft == 'c'
        let l:tmpfile .= '.c'
      elseif &ft == 'cpp'
        let l:tmpfile .= '.cpp'
      endif
    endif
    " if len(l:real_fname) != 0
    "   let l:tmpfile .= l:real_fname
    " endif

    let l:tmpcontent = getline(1, line('$'))
    call writefile(l:tmpcontent, l:tmpfile, 'b')
    " echomsg l:tmpfile

    " let l:file = expand('%:p')
    let l:file = l:tmpfile
    let l:line = line('.')-1
    let l:col = col('.')-1
    let l:command = l:exe." ".a:kind." ".l:file." ".l:line." ".l:col." 2>/dev/null"
    " echomsg l:command
    let l:json = system(l:command)
    if v:shell_error == 0
      let l:d = json_decode(l:json)
      for l:lit in l:d['inserts']
        call append(l:lit['line'], split(l:lit['data'], "\n"))
      endfor
    else
      echoerr "error0: ".v:shell_error
    endif
  endif
endfunction

command! SpookyToString call s:SpookyToString("crunch")
command! SpookyToStringLocals call s:SpookyToString("locals")
command! SpookyToStringBranches call s:SpookyToString("branches")
augroup AugroupToString
  autocmd!
  autocmd FileType c,cpp noremap <buffer> <leader>m <Esc>:SpookyToString<CR>
  autocmd FileType c,cpp noremap <buffer> <leader>l <Esc>:SpookyToStringLocals<CR>
  autocmd FileType c,cpp noremap <buffer> <leader>k <Esc>:SpookyToStringBranches<CR>
augroup END


" ctags {{{
" function! s:f3_shared(pattern, flags, info, kind)
" endfunction

function! s:f3_prototype(pattern, flags, info)
  " return s:f3_shared(pattern, flags, info, '^p')
  " ctags --list-kinds
  " p  function prototypes
  let l:kind = '^p'
  let l:tl = taglist(a:pattern)
  let l:tl2 = copy(l:tl)

  " Note: only prototypes and exact match
  let l:tmp = filter(l:tl, 'v:val.kind =~# "'.l:kind.'" && v:val.name ==? "'.a:pattern.'"')
  " echomsg l:tmp
  if len(l:tmp) == 0
    let l:tmp = filter(l:tl2, 'v:val.name ==? "'.a:pattern.'"')
  endif

  if len(l:tmp) > 1
    let l:tmp = filter(l:tl2, 'v:val.name ==# "'.a:pattern.'"')
  endif

  if len(l:tmp) > 1
    let l:tmp = filter(l:tmp, 'v:val.filename == "'.a:info['buf_ffname'].'"')
  endif
  if len(l:tmp) > 1
    " uniq(): strips _consecetive_ duplicates
    call sort(l:tmp)
    call uniq(l:tmp)
  endif

  return l:tmp
endfunction

function! s:f3_definition(pattern, flags, info)
  " echomsg "f3_definition"
  " return s:f3_shared(pattern, flags, info, '^f')

  " ctags --list-kinds
  " f  function definitions
  " s  structure names
  " d  DEFINE
  let l:tl = taglist(a:pattern)

  " Note: only prototypes and exact match
  if len(l:tl) > 1
    " echomsg l:tl
    " echomsg a:pattern
  endif

  let l:tmp = []
  let l:cases = [1, 0]
  let l:kinds = ['^f', '^s', '^d']

  for l:case in l:cases
    for l:kind in l:kinds
      if l:case == 1
        let l:tmp = filter(copy(l:tl), 'v:val.kind =~# "'.l:kind.'" && v:val.name ==# "'.a:pattern.'"')
      else
        let l:tmp = filter(copy(l:tl), 'v:val.kind =~# "'.l:kind.'" && v:val.name ==? "'.a:pattern.'"')
      endif

      if len(l:tmp) > 0
        break
      endif
    endfor

    if len(l:tmp) > 0
      break
    endif
  endfor

  if len(l:tmp) == 0
    let l:tmp = filter(l:tl, 'v:val.name ==# "'.a:pattern.'"')
    if len(l:tmp) == 0
      let l:tmp = filter(l:tl, 'v:val.name ==? "'.a:pattern.'"')
    endif
  endif

  if len(l:tmp) > 1
    " uniq(): strips _consecutive_ duplicates
    call sort(l:tmp)
    call uniq(l:tmp)
  endif

  if len(l:tmp) > 1
    " try filter exact match
    " echomsg l:tmp
    let l:tmp2 = filter(copy(l:tmp), 'v:val.name ==# "'.a:pattern.'"')
    if len(l:tmp2) > 0
      let l:tmp = l:tmp2
    endif
  endif

  if len(l:tmp) > 1
    " try filter same file
    " echomsg l:tmp
    let l:tmp2 = filter(copy(l:tmp), 'v:val.filename == "'.a:info['buf_ffname'].'"')
    if len(l:tmp2) > 0
      let l:tmp = l:tmp2
    endif
  endif
  " echomsg l:tmp

  " if len(l:tmp) > 1
  "   " TODO if cursor is already on a entry in l:tmp
  "   echomsg l:tmp
  " endif

  return l:tmp
endfunction

" setup tagfunc, exec :tjump with name, restore tagfunc
function! s:sp_tag(tagfunc, name) abort
  if strlen(a:name) == 0
    return
  endif

  " echomsg '|'.a:name.'|'
  let l:error = 0
  try
    let oldfunc = &tagfunc
    let &tagfunc = a:tagfunc
    exec 'tjump '.a:name
    " clear error
    echon ''
  catch /^Vim\%((\a\+)\)\=:E426:/
    let l:error = 1
  " E426: tag not found: xxx
    echohl ErrorMsg
    echom v:exception
    echohl None
  finally
    let &tagfunc = oldfunc
  endtry

  if !l:error
    execute 'normal zt'
  endif
endfunction

map <silent> <f10> <c-]> <bar> :execute 'normal zt'<cr>
nnoremap <silent> <f11> :call <sid>sp_tag("<sid>f3_prototype", expand('<cword>'))<cr>
" nnoremap <silent> <f10> :call <sid>sp_tag("<sid>f3_definition", expand('<cword>'))<cr>

" open tag
" map <silent> <F3> <c-]>
" open tag in vertical split
nmap <silent> <f3> <c-]> <bar> :execute 'normal zt'<cr>
" previous
" map <silent> <A-Left> <c-t>

function! s:maybe_unmap() abort
  if maparg('<f3>')
    unmap <f3>
  endif
endfunction

augroup AugroupCtags
  autocmd!
  autocmd FileType c,cpp call s:maybe_unmap()
" <silent> 
" https://vi.stackexchange.com/questions/20241/jumping-to-prototype-or-definition-of-a-function-using-tags
  autocmd FileType c,cpp nnoremap <buffer> <silent> <f3> :call <sid>sp_tag("<sid>f3_definition", expand('<cword>'))<cr>
  " autocmd FileType c,cpp nnoremap <silent> <C-f3> :call <sid>sp_tag("<sid>f3_prototype", expand('<cword>'))<cr>
augroup END

" ctags - look in the current directory for 'tags',
" and work up the tree towards root until one is found
set tags=./.tags;/

" - TODO more general debug of tags
" - TODO glib colours
"   TODO :help tagstack-examples
"   TODO markdown colored block
"   TODO cglobal
"   TODO # is not a valid vim comment
"   TODO [r] readonly flag is not alwasy displayed
"   TODO fzf should search at root of the root-repo (when there are recursive git repos)
" }}}
