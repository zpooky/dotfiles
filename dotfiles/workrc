export http_proxy="http://wwwproxy.se.axis.com:3128"
export HTTP_PROXY="${http_proxy}"

export ftp_proxy="http://wwwproxy.se.axis.com:3128"
export FTP_PROXY="${ftp_proxy}"

export https_proxy="http://wwwproxy.se.axis.com:3128"
export HTTPS_PROXY="${https_proxy}"

export no_proxy=192.168.0.21,192.168.0.0/16,localhost,127.0.0.1,127.0.1.1,.localdomain,axis.com
export NO_PROXY=${no_proxy}

# export ftp_proxy="ftp://ftp-proxy.se.axis.com:4514/"
# export FTP_PROXY="ftp://ftp-proxy.se.axis.com:4514/"
# export socks_proxy="socks://socks.axis.com:1080/"
# export SOCKS_PROXY="socks://socks.axis.com:1080/"

# source to give access to build tools functions
source ~/development/axis/oe-setup/oe-setup.sh

if [ -e ~/development/xcam-scan ]; then
  export PATH=$PATH:~/development/xcam-scan
fi

if [ -e ~/go ]; then
  export PATH=~/go/bin:$PATH
  export GOPATH=~/gopath
  if [ -e "${GOPATH}" ]; then
    export PATH=$GOPATH/bin:$PATH
  fi
fi

if [ -e "${HOME}/.nvm" ]; then
  # https://github.com/nvm-sh/nvm#manual-install
  export NVM_DIR="${HOME}/.nvm"
  [ -s "${NVM_DIR}/nvm.sh" ] && \. "${NVM_DIR}/nvm.sh" # This loads nvm
  # [ -s "${NVM_DIR}/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
fi

axis_enable_root_192_168_0_90(){
  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}
  local resp=$(curl --noproxy "*" --connect-timeout 5 "http://${l_ip}/axis-cgi/pwdgrp.cgi?action=add&user=root&pwd=pass&grp=root&sgrp=admin:operator:viewer:ptz" -w "%{http_code}" 2>/dev/null)
  echo "${resp}"

  local code=$(echo "${resp}" | tail -1)

  if [ "${code}" = "200" ]; then
    return 0
  elif [ "${code}" = "401" ]; then
    return 1
  fi

  return 2
}

setup_ssh_eager() {
  local res=1
  local cnt=0
  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}
  local disable_setup="/tmp/disable_setup"

  local tout=2
  local max_time=240

  # nc -w is timeout in seconds
  while [ ! $res -eq 0 ] && [ $cnt -lt $max_time ]; do
    echo "nc -vz -w ${tout} ${l_ip} 80 2> /dev/null"
    nc -vz -w ${tout} ${l_ip} 80 2> /dev/null
    res=$?
    sleep 1
    cnt=$((cnt+tout+1))
  done

  if [ ! $res -eq 0 ]; then
    notify-send "GAVE UP HTTP probe" "after $cnt seconds"
    return 1
  fi

  local res=2
  while [ $res -eq 2 ] && [ $cnt -lt $max_time ]; do
    axis_enable_root_192_168_0_90
    res=$?
    sleep ${tout}s
    cnt=$((cnt+tout))
  done

  if [ ! $res -eq 2 ]; then
    touch "${disable_setup}"
  else
    notify-send "GAVE UP setup root account" "after $cnt seconds"
    return 1
  fi

  sleep 5
  cnt=$((cnt+5))

  res=1
  while [ ! $res -eq 0 ] && [ $cnt -lt $max_time ]; do
    $HOME/development/axis/tpp/ff enable-ssh 2>&1
    res=$?

    if [ ! $res -eq 0 ]; then
      echo "nc -vz -w ${tout} ${l_ip} 22 2> /dev/null"
      nc -vz -w ${tout} ${l_ip} 22 2> /dev/null
      res=$?
    fi

    if [ ! $res -eq 0 ]; then
      sleep $tout
      cnt=$((cnt+tout))
    fi
  done

  if [ ! $res -eq 0 ]; then
    notify-send "GAVE UP enable-ssh" "after $cnt seconds"
    return 1
  fi

  res=1
  while [ ! $res -eq 0 ] && [ $cnt -lt $max_time ]; do
    echo "nc -vz -w ${tout} ${l_ip} 22 2> /dev/null"
    nc -vz -w ${tout} ${l_ip} 22 2> /dev/null
    res=$?
    sleep 1
    cnt=$((cnt+tout+1))
  done

  if [ ! $res -eq 0 ]; then
    notify-send "GAVE UP nc port 22" "after $cnt seconds"
    return 1
  fi

  res=1
  while [ ! $res -eq 0 ] && [ $cnt -lt $max_time ]; do
    ssh_192_168_0_90_execute "ls"
    res=$?
    sleep 1
    cnt=$((cnt+1))
  done

  if [ ! $res -eq 0 ]; then
    notify-send "GAVE UP ssh ls" "after $cnt seconds"
    return 1
  fi

  return ${res}
}


ssh_192_168_0_90() {
# Note: PS1 runs only once
# echo 'export PS1="\n\u\e[0;34m:\e[0m\$(cat /tmp/product)\e[0;34m:\e[0m\w         [\$?][\$(date +%_H:%_M:%S)][\h]\n\$ "' > \${tmp_conf}
# export PS1="\n\u\e[0;34m:\e[0m$(cat /tmp/product)\e[0;34m:\e[0m\w         [$?][$(date +%_H:%_M:%S)][\h]\n\$ "
  sshx() {
    local l_user="root"
    local l_pass="pass"
    local l_ip=${AXIS_TARGET_IP:-192.168.0.90}

    local l_env_setup='ENV=$HOME/.shinit; export ENV;'
    local l_env=$(cat <<-END
parhandclient set root.System.CaptureFrequencySet yes && parhandclient set root.System.CaptureModeSet yes &
tmp_conf2=$(mktemp)
parhandclient get root.Brand.ProdNbr \${tmp_conf2} raw && mv \${tmp_conf2} /tmp/product &
tmp_conf=$(mktemp)
echo "alias ll=\"ls -alh\"" > \${tmp_conf}
echo 'export PS1="\n\u\e[0;34m:\e[0m\$(cat /tmp/product)\e[0;34m:\e[0m\w         [\h]\n\$ "' >> \${tmp_conf}
echo "alias systemctl_status=\"systemctl status audiocontrol monolith parhand ioboxd -l\"" >> \${tmp_conf}
echo "alias systemctl_root=\"cd /usr/lib/systemd/system\"" >> \${tmp_conf}
echo "alias port_scan=\"netstat -lnptux\"" >> \${tmp_conf}
echo "alias sp-sd=\"cd /var/spool/storage/SD_DISK\"" >> \${tmp_conf}
# AF_UNIX socket
echo "alias unix_con=\"netstat -apnx\"" >> \${tmp_conf}

echo 'watch() {' >> \${tmp_conf}
echo '  if [ -e /usr/bin/watch ]; then' >> \${tmp_conf}
echo '    /usr/bin/watch \$@' >> \${tmp_conf}
echo '  else' >> \${tmp_conf}
echo '  while [ 1 ]; do' >> \${tmp_conf}
echo '    echo \"-------------------------------------------------------------------------------\"' >> \${tmp_conf}
echo '    eval \$1;' >> \${tmp_conf}
echo '    sleep 1;' >> \${tmp_conf}
echo '  done' >> \${tmp_conf}
echo '  fi' >> \${tmp_conf}
echo '}' >> \${tmp_conf}

echo 'tree() {' >> \${tmp_conf}
echo '  if [ -e /usr/bin/tree ]; then' >> \${tmp_conf}
echo '    /usr/bin/tree \$@' >> \${tmp_conf}
echo '  else' >> \${tmp_conf}
echo '    ls -alhR1' >> \${tmp_conf}
echo '  fi' >> \${tmp_conf}
echo '}' >> \${tmp_conf}

echo 'vim() {' >> \${tmp_conf}
echo '  if [ -e  /usr/bin/vim ]; then' >> \${tmp_conf}
echo '    /usr/bin/vim \$@' >> \${tmp_conf}
echo '  elif [ -e  /usr/bin/vim.tiny ]; then' >> \${tmp_conf}
echo '    /usr/bin/vim.tiny \$@' >> \${tmp_conf}
echo '  else' >> \${tmp_conf}
echo '    vi \$@' >> \${tmp_conf}
echo '  fi' >> \${tmp_conf}
echo '}' >> \${tmp_conf}

echo 'gdb() {' >> \${tmp_conf}
echo '  echo "set auto-load safe-path /" > ~/.gdbinit' >> \${tmp_conf}
echo '  /usr/bin/gdb \$@' >> \${tmp_conf}
echo '}' >> \${tmp_conf}

echo "alias dmesg_tail=\"while true; do dmesg -c ; sleep 1 ; done\"" >> \${tmp_conf}

echo "alias systemd_failed=\"systemctl --state=failed\"" >> \${tmp_conf}

echo "info() {" >> \${tmp_conf}
echo '  echo "product: \$(parhandclient get root.Brand.ProdShortName)"' >> \${tmp_conf}
echo '  echo "HWID: \$(bootblocktool -x HWID)"' >> \${tmp_conf}
# TODO show ip "ip addr show dev eth0 scope global | grep inet"
echo "  bootblocktool -lw" >> \${tmp_conf}
echo "  ip -4 addr show eth0 scope global | tail -2 | head -1 | xargs" >> \${tmp_conf}
echo "  echo " >> \${tmp_conf}
echo "}" >> \${tmp_conf}

echo "f() {" >> \${tmp_conf}
echo '  find -iname "*\${1}*"' >> \${tmp_conf}
echo "}" >> \${tmp_conf}
mv \${tmp_conf} ~/.shinit
END
)

  # -o StrictHostKeyChecking=no
  # avoid: "Are you sure you want to continue connecting (yes/no/[fingerprint])? "

    # echo "${l_env}"
    # echo "TERM=xterm sshpass -p \"${l_pass}\" ssh -o StrictHostKeyChecking=no -t ${l_user}@${l_ip} \"${l_env_setup} exec /bin/sh -l\""
    TERM=xterm sshpass -p "${l_pass}" ssh -o ServerAliveInterval=1 -o ServerAliveCountMax=2 -o ForwardX11=no -o StrictHostKeyChecking=no -t ${l_user}@${l_ip} "${l_env_setup} ${l_env}; exec /bin/sh -l"
    return $?
  }

  sshx
  local res=$?
  echo "res: $res"
  if [ $res -eq 127 ]; then
    echo ""
  # elif [ $res -eq 255 ]; then
  #   echo ""
  elif [ ! $res -eq 0 ]; then

    setup_ssh_eager
    if [ $? -eq 0 ]; then
      sshx
    fi
  fi

  date
  # hides functions from global scope
  unset -f sshx
}


scp_192_168_0_90() {
  local l_user="root"
  local l_pass="pass"
  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}

  local l_source="$1"
  local l_remote_dest="$2"
  if [ ! -e "${l_source}" ]; then
    echo "not existing src: '${l_source}'"
    return 1
  fi

  axis_enable_root_192_168_0_90

  sshpass -p "${l_pass}" scp "${l_source}" "${l_user}"@"${l_ip}":"${l_remote_dest}"
}

scp_crashdump_192_168_0_90(){
  local l_user="root"
  local l_pass="pass"
  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}

  local l_source='/var/spool/storage/SD_DISK/dumps/*'
  local l_dest="~/development/crashdump/"

  axis_enable_root_192_168_0_90

  echo "sshpass -p ${l_pass} scp ${l_user}@${l_ip}:${l_source} ${l_dest}"
  sshpass -p "${l_pass}" scp "${l_user}"@"${l_ip}":"${l_source}" "${l_dest}"
}

# crashdump_gdb_(){
#   if [ ! -n "${BUILDDIR}" ]; then
#     echo "Must be run from oe-initenv shell">&2
#     return 1
#   fi
#
#   get_build(){
#     # BUILDDIR=/home/fredriol/dists/m3047-iobox-duo-sound/builds/m3047-p
#   }
# # $BUILDDIR
# }

valid_build_dir() {
  if [ ! -n "${BUILDDIR}" ]; then
    echo "Must be run from oe-initenv shell">&2
    return 1
  fi

  if [[ ! "$(pwd)" =~ ^${BUILDDIR}.* ]]; then
    echo "ERROR: You are not located under the directory of oe-initenv ('${BUILDDIR}')"
    return 1
  fi

  return 0
}

overlay_mount_192_168_0_90_async(){
  local l_fwmgr_local="/tmp/fwmgr.conf"
  local l_fwmgr_remote="/etc/fwmgr.conf"

  local l_user="root"
  local l_pass="pass"
  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}
  local res=0

  echo "sshpass -p ${l_pass} scp ${l_user}@${l_ip}:${l_fwmgr_remote} ${l_fwmgr_local}"
  sshpass -p "${l_pass}" scp "${l_user}"@"${l_ip}":"${l_fwmgr_remote}" "${l_fwmgr_local}"
  if [ ! $? -eq 0 ]; then
    echo "- mounting overlay fs"
    echo "overlay_usr=all" > "${l_fwmgr_local}"

    echo "sshpass -p ${l_pass} scp ${l_fwmgr_local} ${l_user}@${l_ip}:${l_fwmgr_remote}"
    sshpass -p "${l_pass}" scp "${l_fwmgr_local}" "${l_user}"@"${l_ip}":"${l_fwmgr_remote}"
    res=$?

    if [ ! $res -eq 0 ]; then
      echo "failed mounting"
      return $res
    fi

    reboot_192_168_0_90_async
  else
    echo "- already mounted overlay fs"
  fi

  return ${res}
}

overlay_mount_192_168_0_90(){
  # TODO duplicate
  local l_fwmgr_local="/tmp/fwmgr.conf"
  local l_fwmgr_remote="/etc/fwmgr.conf"

  local l_user="root"
  local l_pass="pass"
  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}
  local res=0

  echo "sshpass -p ${l_pass} scp ${l_user}@${l_ip}:${l_fwmgr_remote} ${l_fwmgr_local}"
  sshpass -p "${l_pass}" scp "${l_user}"@"${l_ip}":"${l_fwmgr_remote}" "${l_fwmgr_local}"
  if [ ! $? -eq 0 ]; then
    echo "- mounting overlay fs"
    echo "overlay_usr=all" > "${l_fwmgr_local}"

    echo "sshpass -p ${l_pass} scp ${l_fwmgr_local} ${l_user}@${l_ip}:${l_fwmgr_remote}"
    sshpass -p "${l_pass}" scp "${l_fwmgr_local}" "${l_user}"@"${l_ip}":"${l_fwmgr_remote}"
    res=$?

    if [ ! $res -eq 0 ]; then
      echo "failed mounting"
      exit $res
    fi

    reboot_192_168_0_90
  else
    echo "- already mounted overlay fs"
  fi

  return ${res}
}

sp_add_prefix(){
  local prefix=${1}
  shift 1
  local arg=("${@}")
  out=()
  local b

  for i in "${arg[@]}"; do
    b=$(basename "${i}")
    # echo "- ${prefix}|${b}"
    out+=("${prefix}${b}")
  done
}

deploy_single_192_168_0_90(){
  local project="${1}"
  local project_dir="${BUILDDIR}/workspace/sources/${project}"
  echo "\n\n=============deploy_single_192_168_0_90 ${project}====================="

  local l_reboot=false
  local l_systemd=false
  # local l_systemd_restart=false

  local l_user="root"
  local l_pass="pass"
  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}

  if [ ! -e "${project_dir}" ]; then
    echo "'${project_dir}' does not exist" >&2
    return 2
  fi

  # local install_from_root="${project_dir}/oe-workdir/package"
  local install_from_root="${project_dir}/oe-workdir/image"

  if [ "${project}" = "ioboxd" ]; then
    local l_dest=("/usr/bin/ioboxd")
    local l_source=("${install_from_root}/usr/bin/ioboxd")
    local l_systemd_name="ioboxd"
    l_systemd=true
  elif [ "${project}" = "monolith" ]; then
    local l_dest=("/usr/bin/monolith")
    local l_source=("${install_from_root}/usr/bin/monolith")
    local l_systemd_name="monolith"
    l_systemd=true
  elif [ "${project}" = "wsd" ]; then
    local l_dest=("/usr/bin/wsd")
    local l_source=("${install_from_root}/usr/bin/wsd")
    local l_systemd_name="wsd"
    l_systemd=true
  elif [ "${project}" = "sipd" ]; then
    local l_dest=("/usr/bin/sipd")
    local l_source=("${install_from_root}/usr/bin/sipd")
    local l_systemd_name="sipd"
    l_systemd=true
  elif [ "${project}" = "audiocontrol" ]; then
    local l_dest=("/usr/bin/audiocontrol")
    local l_source=("${install_from_root}/usr/bin/audiocontrol")
    local l_systemd_name="audiocontrol"
    l_systemd=true
  elif [ "${project}" = "audio-streaming-caps-cgi" ]; then
    local l_dest=("/usr/html/axis-cgi/audio/streamingcapabilities.cgi")
    local l_source=("${install_from_root}/usr/html/axis-cgi/audio/streamingcapabilities.cgi")
    local l_systemd_name="httpd"
    l_systemd=true
  elif [ "${project}" = "parhand" ]; then
    local l_dest=("/usr/bin/parhand" "/usr/bin/parhand-systemctl" "/usr/lib/libparhand.so")
    local l_source=("${install_from_root}/usr/bin/parhand" "${install_from_root}/usr/bin/parhand-systemctl" "${install_from_root}/usr/lib/libparhand.so")
    local l_systemd_name="parhand"
    l_systemd=true
  elif [ "${project}" = "libservice-registry" ]; then
    local l_dest=("/usr/lib/libservice_registry.so")
    local l_source=("${install_from_root}/usr/lib/libservice_registry.so")
    local l_systemd_name="confcache"
    l_systemd=true
  elif [ "${project}" = "audio-service" ]; then
    local l_dest=("/usr/bin/audio-service")
    local l_source=("${project_dir}/audio-service/oe-workdir/package/usr/bin/audio-service")
    local l_systemd_name="audio-service"
    l_systemd=true
  elif [ "${project}" = "audiodevicecontrol-cgi" ]; then
    local l_dest=("/usr/html/axis-cgi/audiodevicecontrol.cgi")
    local l_source=("${install_from_root}/usr/html/axis-cgi/audiodevicecontrol.cgi")
    local l_systemd_name="httpd"
    l_systemd=true
  elif [ "${project}" = "device-monitor" ]; then
    local l_dest=("/usr/bin/dmonitord")
    local l_source=("${install_from_root}/usr/bin/dmonitord")
    local l_systemd_name="device-monitor"
    l_systemd=true
  elif [ "${project}" = "stm32f070xx-init" ]; then
    local l_dest=("/usr/libexec/stm32f070xx-setup")
    # local l_source="${install_from_root}/usr/libexec/stm32f070xx-setup"
    local l_source="${project_dir}/stm32f070xx-setup"
    local l_systemd_name="stm32f070xx-setup"
    l_systemd=true
  elif [ "${project}" = "dynamic-device-init" ]; then
    local l_dest=("/usr/libexec/dynamic-device-init")
    local l_source=("${install_from_root}/usr/libexec/dynamic-device-init")
    local l_systemd_name="dynamic-device-init"
    l_systemd=true
  elif [ "${project}" = "digital-camviewsetupd" ]; then
    local l_dest=("/usr/bin/camviewsetupd")
    local l_source=("${install_from_root}/usr/bin/camviewsetupd")
    local l_systemd_name="camviewsetupd"
    l_systemd=true
  elif [ "${project}" = "actionengined" ]; then
    local l_dest=("/usr/bin/actionengined")
    local l_source=("${install_from_root}/usr/bin/actionengined")
    local l_systemd_name=(action-engine-user action-engine-system)
    l_systemd=true
  elif [ "${project}" = "libevent2" ]; then
    local l_dest=("/usr/lib/libevent2.so")
    local l_source=("${install_from_root}/usr/lib/libevent2.so")
    local l_systemd_name=(action-engine-user action-engine-system event-bridge confcache)
    l_systemd=true
  elif [ "${project}" = "camviewsetup-cgi" ]; then
    local l_dest=("/usr/bin/camviewsetup-cgi")
    local l_source=("${install_from_root}/usr/bin/camviewsetup-cgi")
    local l_systemd_name="camviewsetup-cgi"
    l_systemd=true
  elif [ "${project}" = "lens-correctiond" ]; then
    local l_dest=("/usr/bin/lens_correctiond")
    local l_source=("${install_from_root}/usr/bin/lens_correctiond")
    local l_systemd_name="lens-correction"
    l_systemd=true
  elif [ "${project}" = "temperature-ctrld" ]; then
    local l_dest=("/usr/bin/temperature_ctrld")
    local l_source=("${install_from_root}/usr/bin/temperature_ctrld")
    local l_systemd_name="temperature-controller"
    l_systemd=true
  elif [ "${project}" = "eventbridged" ]; then
    local l_dest=("/usr/sbin/eventbridged")
    local l_source=("${install_from_root}/usr/sbin/eventbridged")
    local l_systemd_name="event-bridge confcache"
    l_systemd=true
  elif [ "${project}" = "libeventbridge" ]; then
    local l_dest=("/usr/lib/libeventbridge.so")
    local l_source=("${install_from_root}/usr/lib/libeventbridge.so")
    local l_systemd_name="event-bridge confcache"
    l_systemd=true
  elif [ "${project}" = "eventbridge-plugins-propertychanged" ]; then
    local l_dest=("/usr/lib/eventbridge_plugins/libpropertychanged.so")
    local l_source=("${install_from_root}/usr/lib/eventbridge_plugins/libpropertychanged.so")
    local l_systemd_name="event-bridge confcache"
    l_systemd=true
  elif [ "${project}" = "event2" ]; then
    local l_dest=("/usr/bin/event_switch" "/usr/bin/send_event" "/usr/bin/send_legacy_trigger")
    local l_source=("${install_from_root}/usr/bin/event_switch" "${install_from_root}/usr/bin/send_event" "${install_from_root}/usr/bin/send_legacy_trigger")
    local l_systemd_name="event-switch"
    l_systemd=true
  elif [ "${project}" = "network-speaker-pairing" ]; then
    local l_dest=("/usr/bin/network-speaker-pairing" )
    local l_source=("${project_dir}/daemon/network-speaker-pairing")
    local l_systemd_name="network-speaker-pairing"
    l_systemd=true
  elif [ "${project}" = "eventbridge-plugins-audiocontrol" ]; then
    local l_dest=("/usr/share/event/declarations.d/com.axis.AudioControl.RingPowerLimitExceeded.xml" "/usr/share/event/declarations.d/com.axis.AudioControl.DigitalSignalStatusOK.xml" "/usr/share/event/declarations.d/com.axis.AudioControl.DigitalSignalStatusNoSignal.xml" "/usr/share/event/declarations.d/com.axis.AudioControl.DigitalSignalStatus.xml" "/usr/share/event/declarations.d/com.axis.AudioControl.DigitalSignalStatusMetadata.xml" "/usr/share/event/declarations.d/com.axis.AudioControl.DigitalSignalStatusInvalid.xml" "/usr/lib/eventbridge_plugins/libaudiocontrol_digital_signal_status_no_signal.so" "/usr/lib/eventbridge_plugins/libaudiocontrol_digital_signal_status.so" "/usr/lib/eventbridge_plugins/libaudiocontrol_digital_signal_status_invalid.so" "/usr/lib/eventbridge_plugins/libaudiocontrol_digital_signal_status_ok.so" "/usr/lib/eventbridge_plugins/libaudiocontrol_ring_power_limit_exceeded.so" "/usr/lib/eventbridge_plugins/libaudiocontrol_digital_signal_status_metadata.so" "/usr/lib/eventbridge_plugins/libaudiocontrol_audio_analytics_plugin.so")
    local l_source=("${install_from_root}/usr/share/event/declarations.d/com.axis.AudioControl.RingPowerLimitExceeded.xml" "${install_from_root}/usr/share/event/declarations.d/com.axis.AudioControl.DigitalSignalStatusOK.xml" "${install_from_root}/usr/share/event/declarations.d/com.axis.AudioControl.DigitalSignalStatusNoSignal.xml" "${install_from_root}/usr/share/event/declarations.d/com.axis.AudioControl.DigitalSignalStatus.xml" "${install_from_root}/usr/share/event/declarations.d/com.axis.AudioControl.DigitalSignalStatusMetadata.xml" "${install_from_root}/usr/share/event/declarations.d/com.axis.AudioControl.DigitalSignalStatusInvalid.xml" "${install_from_root}/usr/lib/eventbridge_plugins/libaudiocontrol_digital_signal_status_no_signal.so" "${install_from_root}/usr/lib/eventbridge_plugins/libaudiocontrol_digital_signal_status.so" "${install_from_root}/usr/lib/eventbridge_plugins/libaudiocontrol_digital_signal_status_invalid.so" "${install_from_root}/usr/lib/eventbridge_plugins/libaudiocontrol_digital_signal_status_ok.so" "${install_from_root}/usr/lib/eventbridge_plugins/libaudiocontrol_ring_power_limit_exceeded.so" "${install_from_root}/usr/lib/eventbridge_plugins/libaudiocontrol_digital_signal_status_metadata.so" "${install_from_root}/usr/lib/eventbridge_plugins/libaudiocontrol_audio_analytics_plugin.so")
    local l_systemd_name="event-bridge confcache"
    l_systemd=true
  elif [ "${project}" = "libconfiguration-event" ]; then
    local l_dest=("/usr/lib/libconfiguration_event.so")
    local l_source=("${install_from_root}/usr/lib/libconfiguration_event.so")
    local l_systemd_name="event-bridge confcache"
    l_systemd=true
  elif [ "${project}" = "eventbridge-plugins-livestream" ]; then
    local l_dest=("/usr/lib/eventbridge_plugins/liblive_stream.so")
    local l_source=("${install_from_root}/usr/lib/eventbridge_plugins/liblive_stream.so")
    local l_systemd_name="event-bridge confcache"
    l_systemd=true
  elif [ "${project}" = "glib-utils" ]; then
    local l_dest=("/usr/lib/libglib-utils.so")
    local l_source=("${install_from_root}/usr/lib/libglib-utils.so")
    # local l_systemd_name="confcache" #??
    # l_systemd=true
  elif [ "${project}" = "temperature-ctrld-conf" ]; then
# TODO
# ├── etc
# │   └── sysconfig
# │       └── template
# └── usr
#     ├── etc
#     │   └── sysconfig
#     │       └── template
#     │           ├── temperature_ctrld_heater_grp.conf
#     │           ├── temperature_ctrld_heater_par.conf
#     │           ├── temperature_ctrld_sensor_grp.conf
#     │           └── temperature_ctrld_sensor_par.conf
    local l_product=$(basename $BUILDDIR)
    l_product=${l_product:u} # uppsercase
    local l_source=(${project_dir}/${l_product}/oe-workdir/package/usr/share/temperature_ctrld/*)
    sp_add_prefix "/usr/share/temperature_ctrld/" "${l_source[@]}"
    local l_dest=(${out[@]})
    local l_systemd_name="temperature-controller"
    l_systemd=true
  elif [ "${project}" = "powerd" ]; then
    local l_dest=("/usr/bin/powerd" "/usr/lib/power_plugins/libpower_lib.so")
    local l_source=("${install_from_root}/usr/bin/powerd" "${install_from_root}/usr/lib/power_plugins/libpower_lib.so")
    local l_systemd_name="power-controller"
    l_systemd=true
  elif [ "${project}" = "powerd-plugin-lldpd" ]; then
    local l_dest=("/usr/sbin/lldpproxy")
    local l_source=("${install_from_root}/usr/sbin/lldpproxy")
    local l_systemd_name="powerd-plugin-lldpd"
    l_systemd=true
  elif [ "${project}" = "lightd" ]; then
    local l_dest=("/usr/bin/lightd")
    local l_source=("${install_from_root}/usr/bin/lightd")
    local l_systemd_name="light-controller"
    l_systemd=true
  elif [ "${project}" = "lightd-conf" ]; then
    local l_dest=("/usr/share/lightd/led0.conf" "/etc/conf.d/lightd" "/etc/lightd/led0.conf" "/etc/lightd/dimming.conf" "/etc/lightd/illumination.conf" "/etc/lightd/lightd.conf")
    local l_source=("${install_from_root}/usr/share/lightd/led0.conf" "${install_from_root}/etc/conf.d/lightd" "${install_from_root}/etc/lightd/led0.conf" "${install_from_root}/etc/lightd/dimming.conf" "${install_from_root}/etc/lightd/illumination.conf" "${install_from_root}/etc/lightd/lightd.conf")
    local l_systemd_name="light-controller"
    l_systemd=true
  elif [ "${project}" = "io2d-conf" ]; then
    local l_dest=("/usr/share/io2d/conf.xml")
    local l_source=("${install_from_root}/usr/share/io2d/conf.xml")
    local l_systemd_name="io2d"
    l_systemd=true
  elif [ "${project}" = "io2d" ]; then
    local l_dest=("/usr/bin/io2d")
    local l_source=("${install_from_root}/usr/bin/io2d")
    local l_systemd_name="io2d"
    l_systemd=true
  elif [ "${project}" = "libcamblock-eeprom" ]; then
    local l_dest=("/usr/lib/libcamblock_eeprom.so")
    local l_source=("${install_from_root}/usr/lib/libcamblock_eeprom.so")
    l_systemd=false
  elif [ "${project}" = "libwsdutil" ]; then
    local l_dest=("/usr/lib/libwsdutil.so")
    local l_source=("${install_from_root}/usr/lib/libwsdutil.so")
    local l_systemd_name="wsd"
    l_systemd=true
  elif [ "${project}" = "libpositioning" ]; then
    local l_dest=("/usr/lib/libpositioning.so.0")
    local l_source=("${install_from_root}/usr/lib/libpositioning.so.0")
    l_systemd=false
  elif [ "${project}" = "mux-alsa-plugin" ]; then
    local l_dest=("/usr/lib/alsa-lib/libasound_module_pcm_mux_alsa_plugin.so")
    local l_source=("${install_from_root}/usr/lib/alsa-lib/libasound_module_pcm_mux_alsa_plugin.so")
    l_systemd=false
  elif [ "${project}" = "netd" ]; then
    local l_dest=("/usr/sbin/netd" "/usr/libexec/netd_migrate")
    local l_source=("${install_from_root}/usr/sbin/netd" "${install_from_root}/usr/libexec/netd_migrate")
    local l_systemd_name="netd"
    l_systemd=true
  elif [ "${project}" = "mediaclip" ]; then
    local l_dest=("/usr/bin/mediaclip")
    local l_source=("${install_from_root}/usr/bin/mediaclip")
    local l_systemd_name="mediaclip"
    l_systemd=true
  elif [ "${project}" = "mediaclip-cgi" ]; then
# ├── html
# │   └── axis-cgi
# │       ├── lib
# │       │   └── validate_clip_location.sh
# │       ├── mediaclip2.cgi
# │       ├── mediaclip.cgi
# │       ├── playclip.cgi
# │       └── stopclip.cgi
# └── lib
#     └── api-discovery
#         └── api_manifest_mediaclip.conf
    local l_dest=("/usr/html/axis-cgi/mediaclip2.cgi" "/usr/html/axis-cgi/mediaclip.cgi" "/usr/html/axis-cgi/playclip.cgi" "/usr/html/axis-cgi/stopclip.cgi")
    local l_source=("${install_from_root}/usr/html/axis-cgi/mediaclip2.cgi" "${install_from_root}/usr/html/axis-cgi/mediaclip.cgi" "${install_from_root}/usr/html/axis-cgi/playclip.cgi" "${install_from_root}/usr/html/axis-cgi/stopclip.cgi")
    local l_systemd_name="httpd"
    l_systemd=true
  elif [ "${project}" = "imagine-bdc" ]; then
    local l_dest=("/usr/lib/imagine-plugins/libimagine_bdc.so")
    local l_source=("${install_from_root}/usr/lib/imagine-plugins/libimagine_bdc.so")
    local l_systemd_name="vipd@0.service"
    l_systemd=true
  elif [ "${project}" = "actionengined-plugins-mediaclip" ]; then
    local l_dest=("/usr/lib/actionengine_plugins/libmediaclip_plugin.so")
    local l_source=("${install_from_root}/usr/lib/actionengine_plugins/libmediaclip_plugin.so")
    local l_systemd_name=(action-engine-user action-engine-system)
    l_systemd=true
  elif [ "${project}" = "edge-vault-init" ]; then
    local l_dest=("/usr/sbin/edge-vault-init")
    local l_source=("${install_from_root}/usr/sbin/edge-vault-init")
    local l_systemd_name=(edge-vault-init)
    l_systemd=true
  elif [ "${project}" = "opticsd" ]; then
    local l_dest=("/usr/bin/opticsd")
    local l_source=("${install_from_root}/usr/bin/opticsd")
    local l_systemd_name="opticsd"
    l_systemd=true
  elif [ "${project}" = "confcache" ]; then
    local l_dest=("/usr/sbin/confcached")
    local l_source=("${install_from_root}/usr/sbin/confcached")
    local l_systemd_name="confcache"
    l_systemd=true
  elif [ "${project}" = "expat-xmlnode" ]; then
    local l_dest=("/usr/lib/libxmlnode.so.0.1.7")
    local l_source=("${install_from_root}/usr/lib/libxmlnode.so.0.1.7")
    # local l_systemd_name="confcache"
    l_systemd=false
  elif [ "${project}" = "audio-service-plugin-sip" ]; then
    local l_dest=("/usr/lib/audio-service-plugins/libaudio-service-plugin-sip.so")
    local l_source=("${install_from_root}/usr/lib/audio-service-plugins/libaudio-service-plugin-sip.so")
    local l_systemd_name="audio-service"
    l_systemd=true
  elif [ "${project}" = "audio-service-plugin-streamer" ]; then
    local l_dest=("/usr/lib/audio-service-plugins/libaudio-service-plugin-streamer.so")
    local l_source=("${install_from_root}/usr/lib/audio-service-plugins/libaudio-service-plugin-streamer.so")
    local l_systemd_name="audio-service"
    l_systemd=true
  elif [ "${project}" = "glib-2.0" ]; then
    local glib_version="0.6800.4"
    local l_dest=("/usr/lib/libgio-2.0.so.${glib_version}" "/usr/lib/libglib-2.0.so.${glib_version}" "/usr/lib/libgmodule-2.0.so.${glib_version}" "/usr/lib/libgobject-2.0.so.${glib_version}" "/usr/lib/libgthread-2.0.so.${glib_version}")
    local l_source=("${install_from_root}/usr/lib/libgio-2.0.so.${glib_version}" "${install_from_root}/usr/lib/libglib-2.0.so.${glib_version}" "${install_from_root}/usr/lib/libgmodule-2.0.so.${glib_version}" "${install_from_root}/usr/lib/libgobject-2.0.so.${glib_version}" "${install_from_root}/usr/lib/libgthread-2.0.so.${glib_version}")
    l_systemd=false
  elif [ "${project}" = "powerd-conf" ]; then
    local l_product=$(basename $BUILDDIR)
    local l_pconf="${project_dir}/powerd_${l_product}.conf"
    local l_systemd_name="power-controller"
    if [ ! -e ${l_conf} ]; then
      return 1
    fi

    local l_dest="/etc/powerd/powerd.conf"
    echo "sshpass -p ${l_pass} scp ${l_pconf} ${l_user}@${l_ip}:${l_dest}"
    sshpass -p "${l_pass}" scp "${l_pconf}" "${l_user}"@"${l_ip}":"${l_dest}"
    if [ ! $? -eq 0 ]; then
      return 2
    fi
    ssh_192_168_0_90_execute "chown power:power ${l_dest}"
    if [ ! $? -eq 0 ]; then
      return 3
    fi

    ssh_192_168_0_90_execute "systemctl restart ${l_systemd_name}"
    if [ ! $? -eq 0 ]; then
      return 4
    fi

    return 0
  else
    echo "'${project}' is not supported" >&2
    return 3
  fi

  #========================================
  echo "${l_source[@]}: ${#l_source[@]} 1[${l_source[1]}]"
  echo "${l_dest[@]}: ${#l_dest[@]} 1[${l_dest[1]}]"

  if [ ! ${#l_source[@]} -eq ${#l_dest[@]} ]; then
    echo "BUG: Expected as many sources as destinations">&2
    return 4
  fi

  before_sha256=()
  after_sha256=()
  for src in "${l_source[@]}"; do
    before_sha256+=("$(sha256sum ${src})")
  done

  overlay_mount_192_168_0_90_async

  devtool_build "${project}"
  if [ ! $? -eq 0 ]; then
    return 4
  fi

  for src in "${l_source[@]}"; do
    if [ ! -e ${src} ]; then
      echo "missing '${src}'"
      return 5
    fi
  done

  for src in "${l_source[@]}"; do
    if [ ! -f ${src} ]; then
      echo "is not a file '${src}'"
      return 5
    fi
  done

  for src in "${l_source[@]}"; do
    after_sha256+=("$(sha256sum ${src})")
  done

  echo "- curl"

  setup_ssh_eager

  local res=0
  if [ "${l_systemd}" = 'true' ]; then
    for cur in "${l_systemd_name[@]}"; do
      ssh_192_168_0_90_execute "systemctl stop ${cur}"
      local res=$?
      if [ ! $res -eq 0 ]; then
        echo "FAILED: to stop systemd serverice ${cur}"
        break
      fi
    done
  fi
  if [ $res -eq 0 ]; then
    ssh_192_168_0_90_execute "echo '=${project}======$(date)==============================' >> /var/log/error.log"
    ssh_192_168_0_90_execute "echo '=${project}======$(date)==============================' >> /var/log/info.log"
    ssh_192_168_0_90_execute "echo '=${project}======$(date)==============================' >> /var/log/warning.log"
    before_camera_sha256=()
    after_camera_sha256=()

    for dst in "${l_dest[@]}"; do
      before_camera_sha256+=($(sshpass -p "${l_pass}" ssh -t ${l_user}@${l_ip} "sha256sum ${dst}"))
    done

    i=1
    while [ $i -le ${#l_source[@]} ]; do
      echo "sshpass -p '${l_pass}' scp -q '${l_source[$i]}' '${l_user}'@'${l_ip}':'${l_dest[$i]}'"
      sshpass -p "${l_pass}" scp -q "${l_source[$i]}" "${l_user}"@"${l_ip}":"${l_dest[$i]}"
      local res=$?
      if [ ! $res -eq 0 ]; then
        echo "FAILED: to scp ${l_source[$i]} to ${l_dest[$i]}"
        break
      fi
      let i=i+1
    done

    echo "3"
    if [ $res -eq 0 ]; then
      for dst in "${l_dest[@]}"; do
        after_camera_sha256+=($(sshpass -p "${l_pass}" ssh -t ${l_user}@${l_ip} "sha256sum ${dst}"))
      done

      # echo "- systemctl start ${l_systemd_name}"
      # sshpass -p "${l_pass}" ssh -t ${l_user}@${l_ip} "systemctl start ${l_systemd_name}"
      # local res=$?
      # return $res

      echo "# before  LOCAL"
      echo "${before_sha256[@]}"
      echo "# after   LOCAL"
      echo "${after_sha256[@]}"
      echo "# before CAMERA"
      echo "${before_camera_sha256[@]}"
      echo "# after  CAMERA"
      echo "${after_camera_sha256[@]}"

      res=0
      if [ $l_reboot = true ]; then
        reboot_192_168_0_90
        res=$?
      elif [ "${l_systemd}" = 'true' ]; then
        for cur in "${l_systemd_name[@]}"; do
          ssh_192_168_0_90_execute "systemctl start ${cur}"
          local res=$?
          if [ ! $res -eq 0 ]; then
            break
          fi
        done
      else
        echo "none"
      fi
    fi
  fi

  if [ $res -eq 0 ]; then
    notify-send "deploy '${project}' [DONE]"
    echo "OK"
  else
    notify-send "deploy '${project}' [FAILED]"
    echo "FAILED"
  fi

  return $res
}

# TODO sshfs mount camera in some work dir that will be used by makefile
# TODO find command to setup env(to override dest) and run make with corretch binaries
#TODO maybe touch all sources in $project_dir?
deploy_192_168_0_90(){
  if ! valid_build_dir; then
    return 1
  fi

  axis_enable_root_192_168_0_90
  $HOME/development/axis/tpp/ff enable-ssh

  local FAILED=()
  for CURRENT in "${@}"; do
    deploy_single_192_168_0_90 "${CURRENT}"
    if [ ! $? -eq 0 ]; then
      FAILED+=("${CURRENT}")
    fi
  done

  if [ ${#FAILED[@]} -gt 0 ]; then
    # notify-send "deploy '${project}' [FAILED]"
    echo "\n\nFAILED:"
    for CURRENT in "${FAILED[@]}"; do
    echo "- ${CURRENT}"
    done
  fi
}

rtags_all(){
  if ! valid_build_dir; then
    return 1
  fi

  local sources="${BUILDDIR}/workspace/sources"

  for f in "${sources}"/*; do
    if [ -d "${f}" ]; then
      local git_root="${f}/.git"

      if [ -e "${git_root}" ]; then

        echo "# $(dirname ${f})"
        $HOME/dotfiles/lib/bitbake_rtags.sh "${f}"
      else

        echo "should be a git repo: '$git_root'" >&2
        return 1
      fi
    fi
  done

  date
}

devtool_modify() {
  if ! valid_build_dir; then
    return 1
  fi

  local dist_root="${BUILDDIR}/../.."
  local lwd="$(pwd)"

  local failed=""
  local success=""

  # if [ ! -e "${dist_root}/.git" ]; then
  #   echo "Is not a repo">&2
  #   return 1
  # fi


  local proj=( "$@" )
  for cur in "${proj[@]}"; do
    echo "##### devtool modify \"$cur\""
    devtool modify $cur
    if [ $? -eq 0 ]; then
      success="${success} ${cur}"
    else
      failed="${failed} ${cur}"
    fi
    # if [ $? -eq 0 ];then
    #   cd "${dist_root}"
    #   git add .
    #   git commit -m "$cur"
    #   cd "${lwd}"
    # fi
  done

  local msg="modify done"
  if [ ! -z "${success}" ]; then
    success="success: ${success}"
  fi

  if [ ! -z "${failed}" ]; then
    failed="failed: ${failed}"
  fi

  if [ -z "${success}" ]; then
    notify-send "${msg}" "${failed}"
  elif [ -z "${failed}" ]; then
    notify-send "${msg}" "${success}"
  else
    notify-send "${msg}" "${success}" "${failed}"
  fi
}

ssh_192_168_0_90_execute(){
  local l_user="root"
  local l_pass="pass"
  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}

  local cmd="$1"

  echo "sshpass -p ${l_pass} ssh -q ${l_user}@${l_ip} \"${cmd}\"" >&2
  sshpass -p "${l_pass}" ssh -qt ${l_user}@${l_ip} "${cmd}"
  return $?
}


reboot_192_168_0_90_async() {
  local cmd="/usr/sbin/reboot;sleep 4"

  # ssh_192_168_0_90_execute "${cmd}"
  # return $?

  local l_user="root"
  local l_pass="pass"
  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}

    # TODO maybe have ssh "-o ConnectTimeout 1" timeout of 1sec
  echo "sshpass -p ${l_pass} ssh -q -o \"ConnectTimeout 1\" -o \"ControlPersist 1\" ${l_user}@${l_ip} \"${cmd}\""
  sshpass -p "${l_pass}" ssh -qt -o "ConnectTimeout 1" -o "ControlPersist 1" ${l_user}@${l_ip} "${cmd}"
  return $?
}

reboot_192_168_0_90() {
  reboot_192_168_0_90_async
  sleep 5

  setup_ssh_eager
  return $?
}

flash_192_168_0_90_ftp() {
  # TODO grep for "Error: No custom firmware certificate for camera group 'axis-devel-ambarella-s5l'."
  local l_user="root"
  local l_pass="pass"
  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}
  local l_image="./fimage"

http_ok() {
  local cnt=10
  sleep "${cnt}s"
  setup_ssh_eager > /dev/null
  res=$?

  if [ $res -eq 0 ]; then
    notify-send "OK ssh"
  fi
}

  if [[ -n "${1}" ]]; then
    local l_image="${1}"
  elif [[ -n "${BUILDDIR}" ]]; then
    if ! valid_build_dir; then
      return 1
    fi
    local l_image="${BUILDDIR}/fimage"
  fi

  if [ ! -e "${l_image}" ]; then
    notify-send "ERROR missing '${l_image}'"
    echo "missing '${l_image}'" >&2
    echo "Autodetect in oe-initenv shell">&2
    return 1
  fi

  if [ ! -f "${l_image}" ]; then
    notify-send "ERROR not a file '${l_image}'"
    echo "not a file '${l_image}'" >&2
    echo "Autodetect in oe-initenv shell">&2
    return 1
  fi

  sleep 1
  echo
  echo
  sha256sum "${l_image}"
  date
  echo "flashing '${l_image}'"

  axis_enable_root_192_168_0_90
  sleep 2

  # ftp -u ftp://${l_user}:${l_pass}@${l_ip}/flash_all ${l_image}
  # if [ ! $? -eq 0 ]; then
    # $HOME/development/axis/tpp/ff enable-ftp
    local ret=$?
    if [ ${ret} -eq 0 ]; then
      local l_fwmgr_local="/tmp/fwmgr.conf"
      local l_fwmgr_remote="/etc/fwmgr.conf"
      local res=0

      sleep 2s

      rm ${l_fwmgr_local} 2> /dev/null

      echo "sshpass -p ${l_pass} scp -q ${l_user}@${l_ip}:${l_fwmgr_remote} ${l_fwmgr_local}"
      sshpass -p "${l_pass}" scp -q "${l_user}"@"${l_ip}":"${l_fwmgr_remote}" "${l_fwmgr_local}"
      if [ -f ${l_fwmgr_local} ]; then
        ssh_192_168_0_90_execute "rm ${l_fwmgr_remote}"

        reboot_192_168_0_90
        sleep 5s
      fi

      # ftp -u ftp://${l_user}:${l_pass}@${l_ip}/flash_all ${l_image}
      curl -D - -S -s -T ${l_image} ftp://${l_user}:${l_pass}@${l_ip}/flash_all

      # echo "ftp-upload -h ${l_ip} -u ${l_user} --password ${l_pass} -d /flash_all ${l_image}"
      # ftp-upload -h ${l_ip} -u ${l_user} --password ${l_pass} -d /flash_all ${l_image}
      local ret=$?
      if [ ${ret} -eq 0 ]; then
        notify-send "flashing ${l_ip} [DONE]" "${l_image} [DONE]"
        http_ok &
      else
        notify-send "flashing ${l_ip} [FAILED]" "${l_image} [FAILED]"
      fi
    else
      notify-send "ERROR failed enable-ftp"
    fi
  # fi

  date
  return ret
}

bitbake_axis-image-cvp() {
  if ! valid_build_dir; then
    return 1
  fi
  # TODO time
  date

  local fimage="${BUILDDIR}/fimage"
  local fimage_before=$(sha256sum "${fimage}")

  nice bitbake axis-image-cvp
  local ret=$?
  if [ ${ret} -eq 0 ]; then
    notify-send "Build [SUCCESS]"
  else
    notify-send "Build [FAILED]"
  fi
  date

  local fimage_after=$(sha256sum "${fimage}")

  echo "# ${fimage}"
  echo "before: ${fimage_before}"
  echo "after : ${fimage_after}"
  echo
  echo

  return $ret
}

bitbake_axis_ACA() {
  local dist_root="${BUILDDIR}"
  local conf_root="${dist_root}/conf"
  local local_conf="${conf_root}/local.conf"
  local cwd="${PWD}"

  if ! valid_build_dir; then
    return 1
  fi

  local mm=$(grep "EXTERNALSRC_pn-aca" ${local_conf})
  if [ ! $? -eq 0 ]; then
    echo "EXTERNALSRC_pn-aca is not setup in ${local_conf}"
    return $?
  fi

  local regex=[[:space:]]*EXTERNALSRC_pn-aca[[:space:]]*=[[:space:]]*\"(.*)\"[[:space:]]*

  if [[ "${mm}" =~ $regex ]]; then
    local aca_dir="$(eval echo ${match[1]})"
    echo "${aca_dir}"

    if [ ! -e "${aca_dir}" ]; then
      echo "ACA Directory: '${aca_dir}' does not exist"
      return 1
    fi

    cd ${aca_dir}

    echo "# yarn install"
    yarn install
    if [ ! $? -eq 0 ]; then
      cd "${cwd}"
      return $?
    fi

    echo "# yarn build"
    yarn build
    if [ ! $? -eq 0 ]; then
      cd "${cwd}"
      return $?
    fi

    cd "${cwd}"
  else
    echo "regex failed"
    return 1
  fi

  echo "# bitbake -c cleansstate aca"
  bitbake -c cleansstate aca
  if [ ! $? -eq 0 ]; then
    return $?
  fi

  echo "# bitbake axis-image-cvp"
  bitbake axis-image-cvp
  if [ ! $? -eq 0 ]; then
    return $?
  fi

  return 0
}

#ffbuild -c monolith-unittest
#bitbake monolith:do_check
bitbake_clean_all() {
  #                clean # does cleanup work dirs?
  # devtool build -c gstreamer1.0-plugins-bad
  if ! valid_build_dir; then
    return 1
  fi
  local l_workspace="${BUILDDIR}/workspace/sources"

  if [ ! -e ${l_workspace} ]; then
    echo "${l_workspace} does not exist">&2
    return 2
  fi

  date
  echo "###bitbake -c clean $(cd ${l_workspace}; ls -d -- */ | tr '/' ' ' | xargs)">&2

  bitbake -c clean $(cd ${l_workspace}; ls -d -- */ | tr '/' ' ' | xargs)
  local res=$?

  if [ ${res} -eq 0 ]; then
    notify-send "CLEAN [SUCCESS]"
  else
    notify-send "CLEAN [FAILED]"
  fi
  date

  return $res
}

do_touch_dir(){
  ack -f --cpp --fortran --shell --ignore-dir=oe-workdir --ignore-dir=oe-logs -r -- . | xargs touch
  return $?
}

bitbake_touch_all() {
  if ! valid_build_dir; then
    return 1
  fi
  local l_workspace="${BUILDDIR}/workspace/sources"

  if [ ! -e ${l_workspace} ]; then
    echo "${l_workspace} does not exist">&2
    return 2
  fi

  cd ${l_workspace}
  do_touch_dir
  local res=$?
  cd -

  return ${res}
}

bitbake_clean() {
  if ! valid_build_dir; then
    return 1
  fi

  local proj=( "$@" )
  for cur in "${proj[@]}"; do
    echo "###bitbake -c clean ${cur}">&2
    bitbake -c clean "${cur}"
  done
}

entr_devtool_build(){
  if ! valid_build_dir; then
    return 1
  fi

  local project="${1}"
  local l_workspace="${BUILDDIR}/workspace/sources/${project}"

  if [ ! -e "${l_workspace}" ]; then
    echo "missing workspace '${l_workspace}'">&2
    return 1
  fi

  echo "ack -f --cpp --ignore-dir=oe-workdir --ignore-dir=oe-logs -r ${l_workspace}"
  cd ${l_workspace}
  ack -f --cpp --fortran --shell --ignore-dir=oe-workdir --ignore-dir=oe-logs -r | entr -c "$HOME/dotfiles/lib/devtool_build.sh" "${project}"
  cd -
}

devtool_build(){
  if ! valid_build_dir; then
    return 1
  fi

  local project="${1}"
  local l_workspace="${BUILDDIR}/workspace/sources/${project}"

  if [ ! -e "${l_workspace}" ]; then
    echo "missing workspace '${l_workspace}'">&2
    return 1
  fi


  time $HOME/dotfiles/lib/devtool_build.sh "${project}"
  local out=$?

  echo ""

  return out
}


env_setup() {
  local l_args="${@}"

  # -w DIR, --workdir DIR the work directory to setup

  getopt --test
  if [[ $? -ne 4 ]]; then
    echo "I’m sorry, `getopt --test` failed in this environment."
    return 1
  fi

  local l_options="w:m:g:j:"
  local l_longopts="workdir:,manifest-branch:,groups:,jobs:"

  # -use ! and PIPESTATUS to get exit code with errexit set
  # -temporarily store output to be able to check for errors
  # -activate quoting/enhanced mode (e.g. by writing out “--options”)
  # -pass arguments only via   -- "$@"   to separate them correctly
  ! PARSED=$(getopt --options=$l_options --longoptions=$l_longopts --name "$0" -- "$@")
  if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    # e.g. return value is 1
    #  then getopt has complained about wrong arguments to stdout
    return 2
  fi
  # read getopt’s output this way to handle the quoting right:
  eval set -- "$PARSED"

  local l_workdir=

  while true; do
    case "$1" in
      -w|--workdir)
        # echo "workdir $2"
        l_workdir="${2}"
        shift 2
        ;;
      -m|--manifest-branch)
        shift 2
        ;;
      -g|--groups)
        shift 2
        ;;
      -j|--jobs)
        shift 2
        ;;
      --)
        shift
        break
        ;;
      *)
      echo "spooky Unknown argument"
      return 3
      ;;
    esac
  done

  if [[ -z "${l_workdir}" ]]; then
    echo "workspace is not set"
    return 4
  fi

  if [[ -e "${l_workdir}" ]]; then
    echo "workspace already exist '${l_workdir}'"
    return 5
  fi

  "${l_args}"
  if [[ ! $? -eq 0 ]]; then
    return $?
  fi

  if [[ ! -e "${l_workdir}" ]]; then
    echo "workspace does not exist '${l_workdir}'"
    return 6
  fi

  if [[ "$(readlink -f ${l_workdir})" != "$(pwd)" ]]; then
    echo "'$(readlink -f ${l_workdir})' missmatch '$(pwd)'"
    return 7
  fi

  git init
  cp ~/Dropbox/axis/gitignore .gitignore
  git add .
  git commit -m "initial"
}

# TODO portcast-conf
portcast_features(){
  dumpProperties(){
    setProperty(){
      local key=$1
      local value=$2
      local file=$3

      awk -v pat="^$key=" -v value="$key=$value" '{ if ($0 ~ pat) print value; else print $0; }' $file > $file.tmp
      mv $file.tmp $file
    }

    getProperty() {
      local key=$1
      local file=$2
      local value=$(cat "$file" | grep "$key" | cut -d'=' -f2)
      echo $value
    }

    listProperties(){
      local file=$1

      cat "${file}" | cut -d'=' -f1 | xargs
    }

    if [ $# -eq 0 ]; then
      return 10
    fi

    local tmp_file="$(mktemp /tmp/tmp.XXXXXXXXXXXXXX)"

    # echo "arg: $1"
    cat $1 > $tmp_file
    shift

    while [ $# -gt 0 ]; do
      local args=($(listProperties "$1"))

      for key in ${args[@]}; do
        local value=$(getProperty "${key}" "$1")
        # echo "${value} = getProperty ${key} $1"
        setProperty "${key}" "${value}" "${tmp_file}"
      done

      shift
    done

    while IFS='' read -r line || [[ -n "$line" ]]; do
      echo "- ${line}"
    done < "${tmp_file}"

  # echo "${default_audiocontrol_conf}"
  # if [ -e "${audiocontrol_conf_product}" ]; then
  # awk -F= '!a[$1]++' "${default_audiocontrol_prod}" "${audiocontrol_conf_product}"
  # fi

    rm ${tmp_file}

    # hides functions from global scope
    unset -f setProperty getProperty listProperties
  }

  if ! valid_build_dir; then
    return 1
  fi

  local build_root="${BUILDDIR}/../.."
  local machine_root=$(realpath "${build_root}/meta-axis-bsp/conf/machine/axis-config")

  local audiocontrol_conf_root="${BUILDDIR}/workspace/sources/audiocontrol-conf"
  local default_audiocontrol_conf="${audiocontrol_conf_root}/products/default_audiocontrol_prod.inc"

  # echo grep "AXIS_CONFIG_PORTCAST=y" "${machine_root}" -lir
  # echo "${build_root}"
  # echo "${machine_root}"

  # local machine_configs=( $(grep "AXIS_CONFIG_PORTCAST=y" "${machine_root}" -lir) )
  local machine_configs=( $(grep "AXIS_CONFIG_AUDIO=y" "${machine_root}" -lir) )

  # echo ${machine_configs}

  for ax in ${machine_configs[@]};
  do
    local ax_name="$(basename ${ax})"
    local product_name="$(cut -d '.' -f1 <<< $ax_name)"
    local audiocontrol_conf_product="${audiocontrol_conf_root}/products/${product_name}/audiocontrol_prod.inc"
    local audio_sources=$(grep AXIS_CONFIG_AUDIO_SOURCES "${ax}")
    local audio_outputs=$(grep AXIS_CONFIG_AUDIO_OUTPUTS "${ax}")
    local audio_input_internal=$(grep AXIS_CONFIG_AUDIO_INPUT_TYPE_INTERNAL "${ax}")
    local audio_audio_channels=$(grep AXIS_CONFIG_AUDIO_MAX_CHANNELS "${ax}")
# AXIS_CONFIG_AUDIO_INPUT_TYPE_INTERNAL is not set

    if [ "$audio_sources" = "AXIS_CONFIG_AUDIO_SOURCES=1" ]; then
    if [ "$audio_outputs" = "AXIS_CONFIG_AUDIO_OUTPUTS=1" ]; then
    if [[ "$audio_input_internal" =~ "# AXIS_CONFIG_AUDIO_INPUT_TYPE_INTERNAL" ]]; then
    if [ "$audio_audio_channels" = "AXIS_CONFIG_AUDIO_MAX_CHANNELS=1" ]; then
    echo "========================================"
    echo "# ${product_name}"
    # grep "AXIS_CONFIG_AUDIO=" "${ax}" | xargs echo "-"
    grep AXIS_CONFIG_AUDIO_OUTPUTS "${ax}" | xargs echo "-"
    grep AXIS_CONFIG_AUDIO_SOURCES "${ax}" | xargs echo "-"
    grep AXIS_CONFIG_AUDIO_INPUT_TYPE_INTERNAL "${ax}" | xargs echo "-"
    grep AXIS_CONFIG_AUDIO_MAX_CHANNELS "${ax}" | xargs echo "-"
    # grep AXIS_CONFIG_PORTCAST "${ax}" | xargs echo "-"
    fi
    fi
    fi
    fi
    # grep "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_DEFAULT" "${ax}" | xargs echo "- default:"
    # grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_[0-9]+" "${ax}" | xargs -n1 echo "-"
    # grep -E "AXIS_CONFIG_SIP" "${ax}" | xargs echo "-"
    # grep -E "AXIS_CONFIG_AUDIO_INPUT_TYPE_INTERNAL" "${ax}" | xargs echo "-"
    # grep -E "AXIS_CONFIG_AUDIO_INTERNAL_MIC_TYPE_analog" "${ax}" | xargs echo "-"

    # echo "## I/O"
    # grep AXIS_CONFIG_GPIOMAP "${ax}"| xargs echo "?"
    # grep AXIS_CONFIG_IO_INPUTS "${ax}" | xargs echo "?"

    # echo "## audiocontrol-conf"
    # if [ -e "${audiocontrol_conf_product}" ]; then
    #   dumpProperties "${default_audiocontrol_conf}" "${audiocontrol_conf_product}"
    # else
    #   dumpProperties "${default_audiocontrol_conf}"
    # fi

    # echo
  done
}

dump_sample_rates(){
  local build_root="${BUILDDIR}/../.."
  local dir=$(realpath "${build_root}/meta-axis-bsp/conf/machine")
  local name="$(basename ${1})"
  name=${name/".axis-config"/""}
  local prod_conf="${dir}/${name}.conf"

  echo -n "${name}.conf "
  # grep -E "^AXIS_CONFIG_AUDIO=y" "${1}" | xargs echo "-"
  # grep -E "AXIS_CONFIG_AUDIO_SAMPLE_RATE_8KHZ" "${1}" | xargs echo "-"
  # grep -E "AXIS_CONFIG_AUDIO_SAMPLE_RATE_16KHZ" "${1}" | xargs echo "-"
  # grep -E "AXIS_CONFIG_AUDIO_SAMPLE_RATE_32KHZ" "${1}" | xargs echo "-"
  # grep -E "AXIS_CONFIG_AUDIO_SAMPLE_RATE_44_1KHZ" "${1}" | xargs echo "-"
  # grep -E "AXIS_CONFIG_AUDIO_SAMPLE_RATE_48KHZ" "${1}" | xargs echo "-"
  # grep -E "AXIS_CONFIG_PORTCAST" "${1}" | xargs echo "-"
  # if [ -e "${prod_conf}" ]; then
  #   grep "^require " "${prod_conf}" | xargs echo "-"
  # fi
  # echo ""
}

sample_rate_holes(){
  if ! valid_build_dir; then
    return 1
  fi

  local build_root="${BUILDDIR}/../.."
  local dir=$(realpath "${build_root}/meta-axis-bsp/conf/machine/axis-config")
  if [ ! -d ${dir} ]; then
    echo "'$dir' not a dir"
    return 1
  fi

  for cur in "${dir}"/*; do
    local res=0
    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_8KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      res=8
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_16KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      if [ ! $res -eq 8 ]; then
        dump_sample_rates "${cur}"
        continue
      fi
      res=16
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_32KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      if [ ! $res -eq 16 ]; then
        dump_sample_rates "${cur}"
        continue
      fi
      res=32
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_44_1KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      if [ ! $res -eq 32 ]; then
        dump_sample_rates "${cur}"
        continue
      fi
      res=44
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_48KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      if [ ! $res -eq 44 ]; then
        dump_sample_rates "${cur}"
        continue
      fi
      res=48
    fi
  done
}

only_one_sample_rate(){
  if ! valid_build_dir; then
    return 1
  fi

  local build_root="${BUILDDIR}/../.."
  local dir=$(realpath "${build_root}/meta-axis-bsp/conf/machine/axis-config")
  if [ ! -d ${dir} ]; then
    echo "'$dir' not a dir"
    return 1
  fi

  for cur in "${dir}"/*; do
    local cnt=0
    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_8KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      cnt=$((cnt+1))
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_16KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      cnt=$((cnt+1))
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_32KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      cnt=$((cnt+1))
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_44_1KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      cnt=$((cnt+1))
    fi

    grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_48KHZ" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      cnt=$((cnt+1))
    fi

    if [ $cnt -eq 1 ]; then
      echo "${cnt}"
      dump_sample_rates "${cur}"
    fi
  done
}

# sample_rate_highest_44KHz(){
#   if ! valid_build_dir; then
#     return 1
#   fi
#
#   local build_root="${BUILDDIR}/../.."
#   local dir=$(realpath "${build_root}/meta-axis-bsp/conf/machine/axis-config")
#   if [ ! -d ${dir} ]; then
#     echo "'$dir' not a dir"
#     return 1
#   fi
#
#   for cur in "${dir}"/*; do
#     local has_44=0
#     local has_48=0
#     local has_portcast=0
#
#     grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_44_1KHZ" "${cur}" > /dev/null
#     if [ $? -eq 0 ]; then
#       has_44=1
#     fi
#
#     grep -E "^AXIS_CONFIG_AUDIO_SAMPLE_RATE_48KHZ" "${cur}" > /dev/null
#     if [ $? -eq 0 ]; then
#       has_48=1
#     fi
#
#     grep -E "^AXIS_CONFIG_PORTCAST" "${cur}" > /dev/null
#     if [ $? -eq 0 ]; then
#       has_portcast=1
#     fi
#
#     if [ $has_44 -eq 1 ]; then
#       dump_sample_rates "${cur}"
#     fi
#   done
# }

no_sources_outputs(){
  if ! valid_build_dir; then
    return 1
  fi

  local build_root="${BUILDDIR}/../.."
  local dir=$(realpath "${build_root}/meta-axis-bsp/conf/machine/axis-config")
  if [ ! -d ${dir} ]; then
    echo "'$dir' not a dir"
    return 1
  fi

  for cur in "${dir}"/*; do
    local no_sources=0
    local output=0
    grep -E "^AXIS_CONFIG_AUDIO_SOURCES=0" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      no_sources=1
    fi
    grep -E "^AXIS_CONFIG_AUDIO_SOURCES=" "${cur}" > /dev/null
    if [ ! $? -eq 0 ]; then
      no_sources=1
    fi

    grep -E "^AXIS_CONFIG_AUDIO_OUTPUTS=" "${cur}" > /dev/null
    if [ $? -eq 0 ]; then
      output=1
    fi
    if [ $no_sources -eq 1 ] && [ $output -eq 1 ]; then
      local name="$(basename ${cur})"
      name=${name/".axis-config"/""}
      echo "# ${name}"
      grep -E "^AXIS_CONFIG_AUDIO=y" "${cur}" | xargs echo "-"
      grep -E "AXIS_CONFIG_AUDIO_SOURCES" "${cur}" | xargs echo "-"
      grep -E "AXIS_CONFIG_AUDIO_OUTPUTS" "${cur}" | xargs echo "-"
      echo ""
    fi
  done
}

# sp_gen_bsp_multiple() {
#   if ! valid_build_dir; then
#     return 1
#   fi
#
#   local build_root="${BUILDDIR}/../.."
#   local dir=$(realpath "${build_root}/meta-axis-bsp/conf/machine")
#   if [ ! -d ${dir} ]; then
#     echo "'$dir' not a dir"
#     return 1
#   fi
#
#   local products=("fa54" "fritos" "gangsterponymn34220pl" "gangsterponyov4689" "grizzly" "p1364" "p1365-mkii" "p1367" "p1368-e" "p1375" "p1375-e" "p1445-le-3" "p1445-le" "p1447-le" "p1448-le" "p1455-le" "p3245-ve" "p5655-e" "p7304" "q1615-mkii" "q1615-mkiii" "q1645" "q1647" "q1659" "q1700-le" "q1785-le" "q1798-le" "q1952-e" "q3515" "q3517" "q3518" "q3527" "q6074" "q6075" "q8752-e" "q9216-slv" "scratchingelephantmn34220pl" "scratchingelephantov4689" "trocadero-4ch" "trocadero" "trocadero-panorama" "trocadero-thermal")
#   local cur
#   for cur in "${products[@]}"; do
#     gen_bsp -l ${BUILDDIR}/../../meta-axis-bsp/ "${cur}" --menuconfig
#   done
# }

gdb_192_168_0_90(){
  local src="${1}"
  local src_dir="${BUILDDIR}/workspace/sources/${src}"
  if [ "${src}" = "monolith" ]; then
    local bin_dir="${src_dir}/monolith/oe-workdir/package/usr/bin/monolith"
  else
    local bin_dir="${src_dir}/oe-workdir/package/usr/bin/${src}"
  fi

  local gdb_dir="${BUILDDIR}/tmp/work"

  local l_ip=${AXIS_TARGET_IP:-192.168.0.90}

  if ! valid_build_dir; then
    return 1
  fi

  if [ ! -e "${src_dir}" ]; then
    echo "'${src_dir}' does not exist" >&2
    return 2
  fi

  if [ ! -f "${bin_dir}" ]; then
    echo "'${bin_dir}' is not built?" >&2
    return 3
  fi
  # -p -- prints gdb command
  local gdb_str="$(rungdb -p ${bin_dir})"
  if [ ! $? -eq 0 ]; then
    return 4
  fi

  # /.../aarch64-poky-linux-gdb -x gdbinit workspace/sources/ioboxd/oe-workdir/package/usr/bin/ioboxd
  # /home/fredriol/dists/tonfisken/builds/m3077-plve/tmp/work/x86_64-linux/gdb-cross-arm

  local gdbinit="./gdbinit"
  local new_gdbinit="$(mktemp /tmp/gdbinit.XXXXXXXXXXXXXX)"
  if [ ! -f ${gdbinit} ]; then
    return 5
  fi
  echo "target remote ${l_ip}:12345" >> ${gdbinit}

  mv "${gdbinit}" "${new_gdbinit}"
  if [ ! $? -eq 0 ]; then
    return 6
  fi

  local gdb_parts=($(echo ${gdb_str}))
  # for cur in ${gdb_parts[@]}; do
  #   echo "- $cur"
  # done

  local gdb_exe="${gdb_parts[1]}"
  if [ ! -e "${gdb_exe}" ]; then
    return 7
  fi

  # echo "SP_GDB_EXE=${gdb_exe} SP_GDB_SOURCE=${new_gdbinit} $HOME/dotfiles/lib/tmuxgdb/tmuxgdb.sh ${bin_dir}"
  SP_GDB_EXE="${gdb_exe}" SP_GDB_SOURCE="${new_gdbinit}" $HOME/dotfiles/lib/tmuxgdb/tmuxgdb.sh "${bin_dir}"
}

dists_size() {
  local dists="$HOME/dists"

  for dist in "${dists}"/*; do

    if [ -d "${dist}" ]; then
      local build_path="${dist}/builds"

      if [ -e $build_path ]; then
        for machine in "${build_path}"/*; do
          local tmp_path="${machine}/tmp"

          if [ -e "${tmp_path}" ]; then
            echo "${tmp_path}"
          fi
        done
      fi
    fi
  done
}

# repo sync -j10
bitbake_repo_sync(){
  local project_dir="${BUILDDIR}/workspace/appends"
  local meta_axis="${BUILDDIR}/../../meta-axis"
  local meta_axis_bsp="${BUILDDIR}/../../meta-axis-bsp"

  if ! valid_build_dir; then
    return 1
  fi

  if ! repo sync -j10; then
   return $?
  fi

  for dist in "${project_dir}"/*; do
    local fname="$(basename ${dist})"

    if [[ "${fname}" =~ '^(.+)_.*\.bbappend$' ]]; then
      local needle
      local bb_name="${match[1]}"
      # echo "${fname}|${bb_name}"

      local search_dir=""
      if [ "${bb_name}" = "hwconfig" ]; then
        search_dir="${meta_axis_bsp}"
        needle="${bb_name}_"
      elif [ "${bb_name}" = "devicetree" ]; then
        search_dir="${meta_axis_bsp}"
        needle="${bb_name}_"
      elif [ "${bb_name}" = "linux-axis" ]; then
        search_dir="${meta_axis_bsp}"
        if [[ "${fname}" =~ '^(.+_[0-9]+\.[0-9]+\.).*\.bbappend$' ]]; then
          needle="${match[1]}"
        else
          echo "something went wrong"
          return 1
        fi
      else
        search_dir="${meta_axis}"
        needle="${bb_name}_"
      fi
      # echo "find ${search_dir} -name \"${needle}*.bb\""
      local dest_bb=$(find ${search_dir} -name "${needle}*.bb")

      if [ -e "${dest_bb}" ]; then
        local dest_bb_fname="$(basename ${dest_bb})append"

        local src_bbappend="${project_dir}/${fname}"
        local dest_bbappend="${project_dir}/${dest_bb_fname}"
        if [ ! "${fname}" = "${dest_bb_fname}" ]; then
          echo "mv ${src_bbappend} ${dest_bbappend}"
          mv "${src_bbappend}" "${dest_bbappend}"
        else
          echo "'${fname}' UP TO DATE"
        fi
      fi
    fi
  done
}

bitbake_backtrace() {
  if ! valid_build_dir; then
    return 1
  fi
  # TODO
  local dir="${BUILDDIR}/tmp/work/m3077_plve-poky-linux-gnueabi/axis-image-cvp/1.0-r0/rootfs-dbg"
  if [ ! -e "${dir}" ]; then
    echo "${dir} does not exist" 1>&2
    return 2
  fi

  if [ ! $1 ]; then
    echo "missing backtrace" 1>&2
    return 3
  fi

  IFS=$'\n'
  arr=(${1})

  for CURRENT in "${arr[@]}"; do
    regex2='.*\/(.*)\(([a-zA-Z_0-9]+)[+-x0-9]+\)'
    regex='.*\/(.*)\(([+-x0-9]+)\)'
    if [[ "${CURRENT}" =~ $regex ]]; then
      # echo "find ${dir} -name ${BASH_REMATCH[1]} "
      res=$(find "${dir}" -name "${BASH_REMATCH[1]}*" | egrep '.*')
      if [ ! $? -eq 0 ]; then
        # echo "missing ${BASH_REMATCH[1]}"
        # exit 1
        echo "$CURRENT"
      else
        res2=$(echo "$res" | grep -v '\.py$')
        if [ ! $? -eq 0 ]; then
          return 4
        fi
        # echo "res2: $res2"
        echo "addr2line -a -f -e ${res2} ${BASH_REMATCH[2]}" 1>&2
        parts=($(addr2line -a -f -e "${res2}" "${BASH_REMATCH[2]}"))
        # addr2line -a -f -e "${res2}" "${BASH_REMATCH[2]}"
        bs=$(basename "${parts[2]}")
        echo "${parts[1]} $bs"
        # echo "${BASH_REMATCH[1]}"
        # echo "${BASH_REMATCH[2]}"
      fi
    elif [[ "${CURRENT}" =~ $regex2 ]]; then
      # echo "$CURRENT"
      echo "${BASH_REMATCH[2]} ${BASH_REMATCH[1]}"
    else
      echo "$CURRENT"
    fi
  done

}

spooky_boot_axis() {
  local fimage=""

  if [[ -n "${1}" ]]; then
    local fimage="${1}"
  elif [[ -n "${BUILDDIR}" ]]; then
    if ! valid_build_dir; then
      return 1
    fi
    local fimage="${BUILDDIR}/fimage"
  fi

  if [ ! -e ${fimage} ]; then
    notify-send "ERROR missing '${fimage}'"
    echo "fimage does not exist (${fimage})">&2
    return 2
  fi

  if [ ! -f "${fimage}" ]; then
    notify-send "ERROR not a file '${fimage}'"
    echo "not a file '${fimage}'" >&2
    echo "Autodetect in oe-initenv shell">&2
    return 3
  fi

  local bootb="$(ssh_192_168_0_90_execute 'bootblocktool -err -lw')"
  local ret=$?
  if [ ! $ret -eq 0 ]; then
    echo "failed getting existing bootblock" >&2
    return 4
  fi
  local bootb="$(echo $bootb | tr -d '\r' | tr -d '\n' | tr -d '\b' | tr -d '\t' | tr -d '\v' | tr -d '\f')"

  local hwid="$(ssh_192_168_0_90_execute 'bootblocktool -err -x HWID')"
  local ret=$?
  if [ ! $ret -eq 0 ]; then
    echo "failed gettign HWID" >&2
    return 5
  fi
  local hwid="$(echo ${hwid} | tr -d '\r' | tr -d '\n' | tr -d '\b' | tr -d '\t' | tr -d '\v' | tr -d '\f')"

  # echo "${fimage}"
  # echo "${bootb}"
  # echo "${hwid}"

  echo "boot_axis -i ${fimage} -FW ${hwid} -w \"${bootb}\""
  return 0
}

netboot_192_168_0_90(){

  # local l_image="./fimage"
  # local l_machine=""

  # local l_marker="${BUILDDIR}/spmarker"
  # if [[ -e "${l_marker}" ]]; then
  #   local l_machine="$(cat ${l_marker})"
  # fi
  #
  # echo "image '${l_image}'"
  # local l_machine="$(basename ${BUILDDIR})"
  # echo "machine '${l_machine}'"

  # axis_enable_root_192_168_0_90
  #
  # $HOME/development/axis/tpp/ff enable-ssh
  # if [ ! $? -eq 0 ]; then
  #   echo "failed to enable-ssh"
  #   return 1
  # fi
  # sleep 1s

  # $HOME/development/axis/tpp/ff :netboot
  # sleep 1s

    # boot_axis -F -i "${l_image}" -W 76A -v

  # if [[ "${l_machine}" = "m3066-v" ]]; then
  #   echo "boot_axis -F -i ${l_image} -W 7AC -v"
  #   boot_axis -F -i "${l_image}" -W 7AC -v
  #   local ret=$?
  # elif [[ "${l_machine}" = "m3075-v" ]]; then
  #   echo "boot_axis -F -i ${l_image} -W 7AD -v"
  #   boot_axis -F -i "${l_image}" -W 7AD -v
  #   local ret=$?
  # # elif [[ "${l_machine}"="p3225-lv-mkii" ]]; then
  # #   $HOME/development/axis/tpp/ff enable-ssh
  # #   sleep 100ms
  # #   $HOME/development/axis/tpp/ff :netboot
  # #   sleep 1s
  # #   echo "boot_axis -F -i \"${l_image}\" -W 705.4 -v"
  # #   boot_axis -F -i "${l_image}" -W 705.4 -v
  # #   local ret=$?
  # elif [[ "${l_machine}" = "p3235-lv" ]]; then
  #   echo "boot_axis -F -i "${l_image}" -W 77A -v"
  #   boot_axis -F -i "${l_image}" -W 77A -v
  #   local ret=$?
  # elif [[ "${l_machine}" = "m3077-plve" ]]; then
  #   echo "boot_axis -F -i "${l_image}" -W 7E5 -v"
  #   boot_axis -F -i "${l_image}" -W 7E5 -v
  #   local ret=$?
  # else
  #   boot_axis -F -i "${l_image}" -v
  #   local ret=$?
  # fi

  local ret=0
  # setup_ssh_eager
  ret=$?
  if [ ! $? -eq 0 ]; then
    echo "failed setting up ssh">&2
  else
    local cmd="$(spooky_boot_axis ${@})"
    ret=$?

    if [ $ret -eq 0 ]; then
      echo "${cmd}"
      local netb="systemctl reboot -ff netboot; sleep 4"
      ssh_192_168_0_90_execute "${netb}"
      ret=$?

      # if [ ! $ret -eq 0 ]; then
      #     echo "failed to enter netboot mode">&2
      # else
        sleep 3
        eval ${cmd}
        ret=$?
      # fi
    fi
  fi

  if [ ${ret} -eq 0 ]; then
    notify-send "netboot ${l_machine} [DONE]" "${l_image} [DONE]"
    http_ok &
  else
    notify-send "netboot ${l_machine} [FAILED]" "${l_image} [FAILED]"
  fi

  date
  return ret
}

# setxkbmap -option caps:escape

# release shares (daily build?)

# /n/axis_releases/oe/m3048-p/CVP/18.45.5_1
# share:
# /n/slask/fredriol
# \\storage03\n_slask\fredriol

# vim: set ft=sh:
